<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Projection Tool v1</title>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script type="importmap">
        {
            "imports": {
                "react": "https://esm.sh/react@18.2.0",
                "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
                "three": "https://esm.sh/three@0.160.0",
                "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.16?external=react,react-dom,three",
                "@react-three/drei": "https://esm.sh/@react-three/drei@9.99.0?external=react,react-dom,three,@react-three/fiber",
                "lucide-react": "https://esm.sh/lucide-react@0.344.0?external=react"
            }
        }
    </script>

    <style>
        body, html { margin: 0; padding: 0; background-color: black; overflow: hidden; color: white; height: 100%; font-family: 'Inter', sans-serif; }
        #root { width: 100%; height: 100%; }
        .no-select { user-select: none; -webkit-user-select: none; }
        
        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { 
            -webkit-appearance: none; 
            margin: 0; 
        }
        
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #18181b; }
        ::-webkit-scrollbar-thumb { background: #3f3f46; border-radius: 3px; }

        .animate-scale { animation: scaleUp 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }
        @keyframes scaleUp { 0% { transform: scale(0.8); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }
        
        .projection-path { transition: fill 0.1s linear, stroke 0.1s linear; }

        /* Node Grid */
        .node-grid {
            background-image: radial-gradient(#666 1px, transparent 1px);
            background-size: 20px 20px;
        }

        /* YouTube Iframe pointer events fix for dragging */
        iframe { pointer-events: none; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useMemo, useRef, useCallback } from 'react';
        import { createRoot } from 'react-dom/client';
        import * as THREE from 'three';
        import { Canvas, useFrame } from '@react-three/fiber';
        import { OrbitControls, PerspectiveCamera, Grid, Text, Line, Edges, Box } from '@react-three/drei';
        import { Settings, Calculator, Move3d, Eye, EyeOff, Plus, Trash2, Target, Rotate3D, Ruler, Box as BoxIcon, Move, Grid3X3, QrCode, Folder, ChevronRight, ChevronDown, Palette, CheckCircle, Axis3d, MousePointer2, Clapperboard, Image as ImageIcon, Upload, Play, SkipBack, SkipForward, LayoutTemplate, MonitorOff, Film, Timer, Activity, Layers, Workflow, Link, X, Cable, Maximize, AlertTriangle, HardDrive, Database, Youtube, Video, Blend } from 'lucide-react';

        // --- ICONS & HELPERS ---
        const FolderPlus = ({size}) => ( <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 10v6M9 13h6"/><path d="M20 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L9.6 3.9A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2Z"/></svg> );

        // Helper to render a handle circle for nodes
        const HandleCircle = ({ type, title, top, active, onClick }) => {
            let colorClasses = '';
            if (type === 'output') {
                colorClasses = '-right-3.5 bg-gray-600 border-gray-300 hover:bg-blue-500 hover:border-white';
            } else if (type === 'base') {
                colorClasses = '-left-3.5 bg-red-900 border-red-500 hover:bg-red-600';
            } else if (type === 'blend') {
                colorClasses = '-left-3.5 bg-green-900 border-green-500 hover:bg-green-600';
            } else {
                // Default Input
                colorClasses = '-left-3.5 bg-lime-900 border-lime-500 hover:bg-lime-600';
            }

            return (
                <div 
                    className={`absolute w-7 h-7 rounded-full border-2 cursor-pointer z-50 transition-all duration-200 flex items-center justify-center ${colorClasses} ${active ? 'bg-white border-blue-400 scale-125 shadow-[0_0_10px_rgba(59,130,246,0.8)]' : ''}`}
                    style={{ top: `${top}px` }}
                    title={title}
                    data-handle={type}
                    onClick={onClick} 
                >
                    {active && <div className="w-3 h-3 rounded-full bg-blue-500"></div>}
                </div>
            );
        };

        // --- PERSISTENCE ENGINE (IndexedDB) ---
        const DB_NAME = 'ProjectionToolDB';
        const DB_VERSION = 1;

        class PersistenceManager {
            constructor() {
                this.db = null;
                this.ready = this.init();
            }

            init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(DB_NAME, DB_VERSION);
                    request.onupgradeneeded = (e) => {
                        const db = e.target.result;
                        if (!db.objectStoreNames.contains('state')) db.createObjectStore('state');
                        if (!db.objectStoreNames.contains('assets')) db.createObjectStore('assets');
                    };
                    request.onsuccess = (e) => {
                        this.db = e.target.result;
                        resolve();
                    };
                    request.onerror = (e) => reject(e);
                });
            }

            async saveAsset(file) {
                await this.ready;
                const assetId = crypto.randomUUID();
                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction('assets', 'readwrite');
                    const store = tx.objectStore('assets');
                    store.put(file, assetId);
                    tx.oncomplete = () => resolve(assetId);
                    tx.onerror = () => reject(tx.error);
                });
            }

            async getAsset(assetId) {
                await this.ready;
                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction('assets', 'readonly');
                    const store = tx.objectStore('assets');
                    const request = store.get(assetId);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }

            async saveState(key, data) {
                await this.ready;
                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction('state', 'readwrite');
                    const store = tx.objectStore('state');
                    store.put(data, key);
                    tx.oncomplete = () => resolve();
                    tx.onerror = () => reject(tx.error);
                });
            }

            async loadState(key) {
                await this.ready;
                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction('state', 'readonly');
                    const store = tx.objectStore('state');
                    const request = store.get(key);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }

            async clearAll() {
                await this.ready;
                const tx = this.db.transaction(['state', 'assets'], 'readwrite');
                tx.objectStore('state').clear();
                tx.objectStore('assets').clear();
                return new Promise((resolve) => { tx.oncomplete = () => resolve(); });
            }

            async getUsage() {
                if (navigator.storage && navigator.storage.estimate) {
                    const estimate = await navigator.storage.estimate();
                    return {
                        usage: (estimate.usage / 1024 / 1024).toFixed(2),
                        quota: (estimate.quota / 1024 / 1024).toFixed(2)
                    };
                }
                return null;
            }
        }

        const db = new PersistenceManager();

        // --- MATH ENGINE ---
        const solveHomography = (src, dst) => {
            let a = [], b = [];
            for (let i = 0; i < 4; i++) {
                let x = src[i].x, y = src[i].y, u = dst[i].x, v = dst[i].y;
                a.push([x, y, 1, 0, 0, 0, -x*u, -y*u]);
                a.push([0, 0, 0, x, y, 1, -x*v, -y*v]);
                b.push(u); b.push(v);
            }
            const n = 8;
            for (let i = 0; i < n; i++) {
                let maxEl = Math.abs(a[i][i]), maxRow = i;
                for (let k = i + 1; k < n; k++) if (Math.abs(a[k][i]) > maxEl) { maxEl = Math.abs(a[k][i]); maxRow = k; }
                for (let k = i; k < n; k++) { let tmp = a[maxRow][k]; a[maxRow][k] = a[i][k]; a[i][k] = tmp; }
                let tmp = b[maxRow]; b[maxRow] = b[i]; b[i] = tmp;
                for (let k = i + 1; k < n; k++) {
                    let c = -a[k][i] / a[i][i];
                    for (let j = i; j < n; j++) { if (i === j) a[k][j] = 0; else a[k][j] += c * a[i][j]; }
                    b[k] += c * b[i];
                }
            }
            let x = new Array(n).fill(0);
            for (let i = n - 1; i > -1; i--) {
                let sum = 0;
                for (let j = i + 1; j < n; j++) sum += a[i][j] * x[j];
                x[i] = (b[i] - sum) / a[i][i];
            }
            return [[x[0], x[1], x[2]], [x[3], x[4], x[5]], [x[6], x[7], 1]];
        };

        const applyHomography = (H, x, y) => {
            const w = H[2][0] * x + H[2][1] * y + H[2][2];
            const tx = (H[0][0] * x + H[0][1] * y + H[0][2]) / w;
            const ty = (H[1][0] * x + H[1][1] * y + H[1][2]) / w;
            return { x: tx, y: ty };
        };

        const decomposeHomographyWithIntrinsics = (H_raw, throwRatio, widthPx, heightPx) => {
            const fx = throwRatio * widthPx; const fy = fx; 
            const cx = widthPx / 2; const cy = heightPx / 2;
            const K = new THREE.Matrix3(); K.set(fx, 0, cx, 0, fy, cy, 0, 0, 1);
            const K_inv = K.clone().invert();
            const H_matrix = new THREE.Matrix3();
            H_matrix.set(H_raw[0][0], H_raw[0][1], H_raw[0][2], H_raw[1][0], H_raw[1][1], H_raw[1][2], H_raw[2][0], H_raw[2][1], H_raw[2][2]);
            const H_norm = H_matrix.clone().premultiply(K_inv);
            const e = H_norm.elements; 
            let h1 = new THREE.Vector3(e[0], e[1], e[2]);
            let h2 = new THREE.Vector3(e[3], e[4], e[5]);
            let h3 = new THREE.Vector3(e[6], e[7], e[8]);
            const lambda = 1 / ((h1.length() + h2.length()) / 2);
            h1.multiplyScalar(lambda); h2.multiplyScalar(lambda); h3.multiplyScalar(lambda);
            const r1 = h1; const r2 = h2; const r3 = new THREE.Vector3().crossVectors(r1, r2).normalize(); const t = h3;
            const worldToCamRaw = new THREE.Matrix4();
            worldToCamRaw.set(r1.x, r2.x, r3.x, t.x, r1.y, r2.y, r3.y, t.y, r1.z, r2.z, r3.z, t.z, 0, 0, 0, 1);
            const camToWorld = worldToCamRaw.clone().invert();
            const position = new THREE.Vector3(); const quaternion = new THREE.Quaternion(); const scale = new THREE.Vector3();
            camToWorld.decompose(position, quaternion, scale);
            if (position.z < 0) { position.z *= -1; position.x *= -1; quaternion.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), Math.PI)); }
            const up = new THREE.Vector3(0, 1, 0).applyQuaternion(quaternion);
            if (up.y < 0) { quaternion.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,0,1), Math.PI)); }
            const toWall = new THREE.Vector3().subVectors(new THREE.Vector3(0,0,0), position).normalize();
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(quaternion);
            if (forward.dot(toWall) < 0) { quaternion.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), Math.PI)); }
            const correctedCamToWorld = new THREE.Matrix4().compose(position, quaternion, scale);
            const correctedWorldToCam = correctedCamToWorld.clone().invert();
            const fov = 2 * Math.atan(1 / (2 * throwRatio)) * (180 / Math.PI);
            return { position, quaternion, fov, camToWorldMatrix: correctedCamToWorld, worldToCamMatrix: correctedWorldToCam };
        };

        const getCssMatrix = (dstPoints, size = 1000) => {
             const src = [{x:0, y:0}, {x:size, y:0}, {x:size, y:size}, {x:0, y:size}];
             const H = solveHomography(src, dstPoints);
             const m = H;
             return `matrix3d(${m[0][0]}, ${m[1][0]}, 0, ${m[2][0]},${m[0][1]}, ${m[1][1]}, 0, ${m[2][1]},0, 0, 1, 0,${m[0][2]}, ${m[1][2]}, 0, ${m[2][2]})`;
        };

        // --- COMPONENTS ---

        const ProjectorCamera = ({ pose }) => {
            if (!pose) return null;
            const dist = 3; const halfHeight = Math.tan(THREE.MathUtils.degToRad(pose.fov / 2)) * dist; const halfWidth = halfHeight * (16/9);
            return (
                <group position={pose.position} quaternion={pose.quaternion}>
                    <arrowHelper args={[new THREE.Vector3(0, 0, -1), new THREE.Vector3(0, 0, 0), 2, 0x00ffff, 0.4, 0.2]} />
                    <Text position={[0, 0.5, 0]} fontSize={0.15} color="#aaa">TOP</Text>
                    <mesh position={[0, 0, 0]}><boxGeometry args={[0.5, 0.3, 0.7]} /><meshStandardMaterial color="#333" /><Edges color="#666" /></mesh>
                    <mesh position={[0, 0, -0.36]} rotation={[Math.PI/2, 0, 0]}><cylinderGeometry args={[0.12, 0.12, 0.1]} /><meshStandardMaterial color="#111" /><Edges color="#222" /></mesh>
                    <group position={[0,0,0]}>
                         <Line points={[ [0,0,0], [-halfWidth, -halfHeight, -dist], [0,0,0], [halfWidth, -halfHeight, -dist], [0,0,0], [halfWidth, halfHeight, -dist], [0,0,0], [-halfWidth, halfHeight, -dist] ]} color="cyan" opacity={0.3} transparent lineWidth={1} />
                         <Line points={[ [-halfWidth, -halfHeight, -dist], [halfWidth, -halfHeight, -dist], [halfWidth, halfHeight, -dist], [-halfWidth, halfHeight, -dist], [-halfWidth, -halfHeight, -dist] ]} color="cyan" opacity={0.2} transparent lineWidth={1} />
                    </group>
                </group>
            );
        };
        
        const TexturedWall = ({ wall, cue }) => {
            const [tex, setTex] = useState(null);
            useEffect(() => {
                setTex(null);
            }, [cue, wall.id]);

            return (
                <mesh>
                    <boxGeometry args={[wall.width, wall.height, 0.05]} /> 
                    <meshStandardMaterial color={wall.color} transparent opacity={0.3} />
                    <Edges color={wall.color} threshold={15} />
                </mesh>
            );
        };

        const PhysicalObjects = ({ walls, showGuides, currentCue }) => {
            return (
                <group>
                      {walls.map((wall) => {
                          const pos = [wall.pos.x, wall.pos.y, wall.pos.z];
                          const rot = [THREE.MathUtils.degToRad(wall.rot.x), THREE.MathUtils.degToRad(wall.rot.y), THREE.MathUtils.degToRad(wall.rot.z)];
                          return (
                            <group key={wall.id} position={pos} rotation={rot}>
                                <TexturedWall wall={wall} cue={currentCue} />
                                <Text position={[0, wall.height/2 + 0.2, 0]} fontSize={0.2} color="white" outlineWidth={0.02} outlineColor="#000">{wall.name}</Text>
                                {showGuides && <group><axesHelper args={[0.6]} /><Text position={[0, 0, 0.1]} fontSize={0.15} color="white" backgroundColor="black" fillOpacity={0.8}>{`(${wall.pos.x.toFixed(2)}, ${wall.pos.y.toFixed(2)}, ${wall.pos.z.toFixed(2)})`}</Text></group>}
                            </group>
                          )
                      })}
                </group>
            )
        }

        const Scene3D = ({ walls, pose, calibrationWall, showGuides, currentCue }) => {
            const floorY = -calibrationWall.height / 2;
            return (
                <>
                    <color attach="background" args={['#202022']} /> 
                    <PerspectiveCamera makeDefault position={[3, 3, 8]} fov={50} />
                    <OrbitControls />
                    <ambientLight intensity={0.8} />
                    <directionalLight position={[5, 10, 5]} intensity={1} />
                    <Grid position={[0, floorY, 0]} args={[20, 20]} cellSize={1} cellThickness={1} cellColor="#444" sectionColor="#666" fadeDistance={20} />
                    {showGuides && <group position={[0,0,0]}><axesHelper args={[2]} /><Text position={[0.2, 2.2, 0]} fontSize={0.2} color="lime" outlineWidth={0.02} outlineColor="black">World Origin (0,0,0)</Text></group>}
                    <PhysicalObjects walls={walls} showGuides={showGuides} currentCue={currentCue} />
                    {pose && <ProjectorCamera pose={pose} walls={walls} />}
                </>
            );
        };

        const PointHandle = ({ x, y, index, color, isSelected, onDrag, isMoveMode }) => {
            const [isDragging, setIsDragging] = useState(false);
            useEffect(() => {
                if (isDragging) {
                    const handleMouseMove = (e) => onDrag(index, e.clientX, e.clientY);
                    const handleMouseUp = () => setIsDragging(false);
                    window.addEventListener('mousemove', handleMouseMove);
                    window.addEventListener('mouseup', handleMouseUp);
                    return () => window.removeEventListener('mousemove', handleMouseMove);
                }
            }, [isDragging]);
            return (
                <g transform={`translate(${x}, ${y})`} style={{ cursor: isMoveMode ? 'move' : (isSelected ? 'move' : 'default') }} onMouseDown={() => isSelected && setIsDragging(true)}>
                    <circle r="30" fill="transparent" />
                    <circle r="12" fill={isMoveMode ? "#fb923c" : color} fillOpacity={isSelected ? 0.3 : 0.1} />
                    <circle r={isSelected ? 6 : 4} fill={isMoveMode ? "#fb923c" : color} stroke="black" strokeWidth="1" />
                    {isSelected && <text x="15" y="5" fill="white" fontSize="10" className="no-select font-mono pointer-events-none">P{index + 1}</text>}
                </g>
            );
        };

        const WarpedTextureGrid = ({ wallPoints }) => {
            const grid = useMemo(() => {
                const src = [{x:0, y:0}, {x:1, y:0}, {x:1, y:1}, {x:0, y:1}];
                const H = solveHomography(src, wallPoints);
                const cells = [];
                const gridSize = 10; 
                for(let y=0; y<gridSize; y++) {
                    for(let x=0; x<gridSize; x++) {
                        const u = x / gridSize; const v = y / gridSize;
                        const u2 = (x+1) / gridSize; const v2 = (y+1) / gridSize;
                        const p1 = applyHomography(H, u, v); 
                        const p2 = applyHomography(H, u2, v); 
                        const p3 = applyHomography(H, u2, v2); 
                        const p4 = applyHomography(H, u, v2);
                        const isWhite = (x + y) % 2 === 0;
                        cells.push(<path key={`${x}-${y}`} d={`M ${p1.x} ${p1.y} L ${p2.x} ${p2.y} L ${p3.x} ${p3.y} L ${p4.x} ${p4.y} Z`} fill={isWhite ? "white" : "black"} stroke="none" />);
                    }
                }
                return cells;
            }, [wallPoints]);
            return <g opacity="0.6">{grid}</g>;
        };

        // --- BLENDER-STYLE NOISE LIBRARY ---

        const ProceduralLib = {
            // 1. Math Helpers
            lerp: (a, b, t) => a + t * (b - a),
            smoothstep: (t) => t * t * (3 - 2 * t),
            fade: (t) => t * t * t * (t * (t * 6 - 15) + 10),
            
            // Gradient vector table for Perlin noise
            grad3: [
                [1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
                [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
                [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]
            ],
            
            // Permutation table (shuffled 0-255)
            p: new Uint8Array([151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,151]), // Repeated once in init

            init() {
                this.perm = new Uint8Array(512);
                for(let i=0; i<512; i++) this.perm[i] = this.p[i & 255];
            },

            dot(g, x, y) { return g[0]*x + g[1]*y; },

            // 2. Gradient Noise (Better Perlin)
            // Returns -1.0 to 1.0
            noise2D(x, y) {
                if(!this.perm) this.init();
                
                let X = Math.floor(x) & 255;
                let Y = Math.floor(y) & 255;
                
                x -= Math.floor(x);
                y -= Math.floor(y);
                
                let u = this.fade(x);
                let v = this.fade(y);
                
                let A = this.perm[X]+Y, AA = this.perm[A], AB = this.perm[A+1];
                let B = this.perm[X+1]+Y, BA = this.perm[B], BB = this.perm[B+1];
                
                return this.lerp(
                    this.lerp(this.dot(this.grad3[AA % 12], x, y), this.dot(this.grad3[BA % 12], x-1, y), u),
                    this.lerp(this.dot(this.grad3[AB % 12], x, y-1), this.dot(this.grad3[BB % 12], x-1, y-1), u),
                    v
                );
            },

            // 3. Cellular / Voronoi Noise (Blender style)
            // Returns { distance, id }
            // type: 'euclidean', 'manhattan', 'chebychev'
            voronoi(x, y, type = 'euclidean') {
                const xi = Math.floor(x);
                const yi = Math.floor(y);
                
                let minDist = 100;
                let cellId = 0;

                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        const neighborX = xi + i;
                        const neighborY = yi + j;
                        
                        // Hash for random point offset
                        // Simple sin-based pseudo random for deterministic position
                        const n = neighborX * 31 + neighborY * 13;
                        let t = (n << 13) ^ n;
                        const randVal = (1.0 - ((t * (t * t * 15731 + 789221) + 1376312589) & 0x7fffffff) / 1073741824.0);
                        const randVal2 = (1.0 - (((t+1) * ((t+1) * (t+1) * 15731 + 789221) + 1376312589) & 0x7fffffff) / 1073741824.0);

                        const pointX = neighborX + 0.5 + 0.5 * Math.sin(randVal * 6.28);
                        const pointY = neighborY + 0.5 + 0.5 * Math.cos(randVal2 * 6.28);

                        let dist;
                        const dx = x - pointX;
                        const dy = y - pointY;

                        if (type === 'manhattan') dist = Math.abs(dx) + Math.abs(dy);
                        else if (type === 'chebychev') dist = Math.max(Math.abs(dx), Math.abs(dy));
                        else dist = Math.sqrt(dx*dx + dy*dy); // Euclidean

                        if (dist < minDist) {
                            minDist = dist;
                            cellId = randVal;
                        }
                    }
                }
                return { distance: minDist, id: cellId };
            },

            // 4. Fractal Brownian Motion (The "Detail" slider in Blender)
            // Handles Standard, Ridge (Lightning), and Turbulence
            fbm(x, y, octaves, lacunarity = 2, gain = 0.5, type = 'standard') {
                let total = 0;
                let amplitude = 0.5;
                let frequency = 1;
                let maxValue = 0;

                for (let i = 0; i < octaves; i++) {
                    let n = this.noise2D(x * frequency, y * frequency);
                    
                    if (type === 'turbulence') {
                        n = Math.abs(n); // Billowy look
                    } else if (type === 'ridge') {
                        n = 1.0 - Math.abs(n);
                        n = n * n; // Sharpen peaks
                    } else {
                        n = (n + 1) / 2; // Normalize standard to 0-1
                    }

                    total += n * amplitude;
                    maxValue += amplitude;
                    amplitude *= gain;
                    frequency *= lacunarity;
                }
                
                // Normalize back to 0-1
                return total / maxValue;
            },

            // 5. Domain Warping (The "Distortion" effect in Blender)
            warp(x, y, amount) {
                const qx = this.fbm(x, y, 2);
                const qy = this.fbm(x + 5.2, y + 1.3, 2);
                return { x: x + amount * qx, y: y + amount * qy };
            }
        };

        const NoiseCanvas = ({ type = 'perlin', scale = 5, detail = 4, time = 0, distortion = 0 }) => {
            const canvasRef = useRef(null);

            useEffect(() => {
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                const { width, height } = canvas;
                // Reuse buffer if possible for performance
                const imgData = ctx.createImageData(width, height);
                const data = imgData.data;

                // Pre-calculate scaling factors
                const aspect = width / height;
                const noiseScale = scale / 10; 

                for (let i = 0; i < data.length; i += 4) {
                    // Pixel coordinates normalized
                    let u = (i / 4) % width / width;
                    let v = Math.floor((i / 4) / width) / height;
                    
                    // Aspect ratio correction
                    u *= aspect;

                    // Coordinate Space with Time
                    let x = u * scale;
                    let y = v * scale;
                    
                    // Add Time z-scroll
                    const t = time * 0.1;
                    
                    // Domain Warping (Blender Distortion)
                    if (distortion > 0) {
                        const warped = ProceduralLib.warp(x, y + t, distortion);
                        x = warped.x;
                        y = warped.y;
                    }

                    let val = 0;

                    if (type === 'perlin') {
                        // Standard Gradient Noise
                        val = ProceduralLib.noise2D(x, y + t);
                        val = (val + 1) / 2; // -1..1 to 0..1
                    } 
                    else if (type === 'fbm') {
                        // Fractal Noise (Clouds)
                        val = ProceduralLib.fbm(x, y + t, Math.floor(detail));
                    } 
                    else if (type === 'ridge') {
                        // Ridge Multifractal (Lightning/Electricity)
                        val = ProceduralLib.fbm(x, y + t, Math.floor(detail), 2, 0.5, 'ridge');
                    }
                    else if (type === 'worley') {
                        // Cellular (Bubbles/Stone)
                        const vData = ProceduralLib.voronoi(x, y + t, 'euclidean');
                        val = vData.distance; 
                        val = Math.min(1, val); // Clamp
                        val = 1.0 - val; // Invert for "Bubble" look
                    }
                    else if (type === 'cells') {
                        // Cellular ID (Stained Glass look)
                        const vData = ProceduralLib.voronoi(x, y + t, 'euclidean');
                        val = vData.id; 
                    }
                    
                    // Contrast/Clamp curve
                    val = Math.max(0, Math.min(1, val));

                    const color = val * 255;
                    data[i] = color;     // R
                    data[i+1] = color;   // G
                    data[i+2] = color;   // B
                    data[i+3] = 255;     // Alpha
                }
                ctx.putImageData(imgData, 0, 0);
            }, [type, scale, detail, time, distortion]);

            return <canvas ref={canvasRef} width="256" height="256" style={{width: '100%', height: '100%', objectFit: 'cover', imageRendering: 'pixelated'}} />;
        };

        // --- RENDER ENGINE V22 ---

        const getYoutubeId = (url) => {
            const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/;
            const match = url.match(regExp);
            return (match && match[2].length === 11) ? match[2] : null;
        };

        const RenderNode = ({ nodeId, nodes, connections, resolution }) => {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return null;

            const getStyle = () => {
                const fit = node.data.fit || 'fill';
                const scale = node.data.scale || 1;
                const panX = node.data.panX || 50;
                const panY = node.data.panY || 50;
                const stretchX = node.data.stretchX || 1;
                const stretchY = node.data.stretchY || 1;
                
                return {
                    width: '100%', 
                    height: '100%', 
                    objectFit: fit,
                    objectPosition: `${panX}% ${panY}%`,
                    transform: `scale(${scale}) scaleX(${stretchX}) scaleY(${stretchY})`,
                    transformOrigin: 'center center'
                };
            };

            if (node.type === 'color') {
                return <div style={{width: '100%', height: '100%', backgroundColor: node.data.value || 'black'}}></div>;
            }

            if (node.type === 'image') {
                return node.data.value ? <img src={node.data.value} style={getStyle()} /> : null;
            }

            if (node.type === 'video') {
                return node.data.value ? <video src={node.data.value} style={getStyle()} autoPlay loop muted playsInline /> : null;
            }

            if (node.type === 'youtube') {
                const id = node.data.youtubeId || getYoutubeId(node.data.value || "");
                if(!id) return <div className="flex items-center justify-center h-full text-red-500 bg-black">Invalid YT ID</div>;
                // Auto-loop, mute, hide controls
                return (
                    <div style={{width: '100%', height: '100%', overflow:'hidden'}}>
                        <iframe 
                            width="100%" 
                            height="100%" 
                            src={`https://www.youtube.com/embed/${id}?autoplay=1&controls=0&showinfo=0&rel=0&modestbranding=1&mute=1&loop=1&playlist=${id}`} 
                            title="YouTube video player" 
                            frameBorder="0" 
                            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
                            style={{...getStyle(), pointerEvents: 'none'}}
                        ></iframe>
                    </div>
                );
            }

            if (node.type === 'noise') {
                return <NoiseCanvas type={node.data.noiseType} scale={node.data.scale} detail={node.data.detail} time={node.data.time} distortion={node.data.distortion} />;
            }

            if (node.type === 'mix') {
                const baseConn = connections.find(c => c.to === nodeId && c.toHandle === 'base');
                const blendConn = connections.find(c => c.to === nodeId && c.toHandle === 'blend');

                return (
                    <div style={{position: 'relative', width: '100%', height: '100%'}}>
                        <div style={{position: 'absolute', inset: 0}}>
                            {baseConn && <RenderNode nodeId={baseConn.from} nodes={nodes} connections={connections} resolution={resolution} />}
                        </div>
                        {blendConn && (
                            <div style={{
                                position: 'absolute', 
                                inset: 0, 
                                mixBlendMode: node.data.blendMode || 'normal'
                            }}>
                                 <RenderNode nodeId={blendConn.from} nodes={nodes} connections={connections} resolution={resolution} />
                            </div>
                        )}
                    </div>
                );
            }

            return null;
        };

        const ProjectedContent = ({ cueState, walls }) => {
            if(!cueState || !walls) return null;
            const resolution = 1000; 
            return (
                <div className="absolute inset-0 overflow-hidden pointer-events-none">
                    {walls.map(wall => {
                        const outputNode = cueState.nodes?.find(n => n.type === 'output' && n.data.wallId === wall.id);
                        if (!outputNode) return null;
                        const inputConn = cueState.connections?.find(c => c.to === outputNode.id);
                        if (!inputConn) return null;
                        const cssM = getCssMatrix(wall.points, resolution);
                        return (
                            <div key={wall.id} className="absolute left-0 top-0 origin-top-left will-change-transform" style={{ width: `${resolution}px`, height: `${resolution}px`, transform: cssM, overflow: 'hidden' }}>
                                <RenderNode nodeId={inputConn.from} nodes={cueState.nodes} connections={cueState.connections} resolution={resolution} />
                            </div>
                        );
                    })}
                </div>
            );
        };

        // --- NODE EDITOR COMPONENTS ---

        const Node = ({ id, type, x, y, label, selected, onDragStart, onHandleClick, data, updateData, isConnecting, activeConnectionId, onDelete }) => {
            const fileInputRef = useRef(null);

            const handleFile = async (e) => {
                const file = e.target.files[0];
                if(file) {
                    try {
                        const assetId = await db.saveAsset(file);
                        const url = URL.createObjectURL(file);
                        updateData(id, { value: url, assetId: assetId, name: file.name });
                    } catch (err) {
                        console.error("Failed to save asset", err);
                    }
                }
            };

            const isMix = type === 'mix';
            const isMedia = type === 'image' || type === 'video' || type === 'youtube';
            const isOutput = type === 'output';
            const isGenerator = type === 'noise';

            return (
                <div
                    className={`absolute w-64 pb-2 rounded-lg border shadow-xl flex flex-col visible bg-zinc-800/95 backdrop-blur-sm ${selected ? 'border-blue-500 ring-1 ring-blue-500' : 'border-zinc-600'}`}
                    style={{ transform: `translate(${x}px, ${y}px)` }}
                >
                    {/* Header - Movable */}
                    <div 
                        className={`px-3 py-2 rounded-t-lg text-xs font-bold uppercase flex justify-between items-center cursor-grab active:cursor-grabbing ${type === 'output' ? 'bg-lime-900 text-lime-200' : isMedia ? 'bg-purple-900 text-purple-200' : isMix ? 'bg-orange-900 text-orange-200' : 'bg-zinc-700 text-gray-300'}`}
                        onMouseDown={(e) => { e.stopPropagation(); onDragStart(e, id); }}
                    >
                        <span className="flex items-center gap-2">
                            {type === 'image' && <ImageIcon size={14}/>}
                            {type === 'video' && <Video size={14}/>}
                            {type === 'youtube' && <Youtube size={14}/>}
                            {type === 'color' && <Palette size={14}/>}
                            {type === 'noise' && <Activity size={14}/>}
                            {type === 'mix' && <Blend size={14}/>}
                            {type}
                        </span>
                        <div className="flex items-center gap-2">
                            {data?.name && <span className="truncate max-w-[100px] opacity-70" title={data.name}>{data.name}</span>}
                            
                            {/* ðŸ”´ CHANGE: Only show delete if NOT an output/wall node */}
                            {type !== 'output' && (
                                <button onClick={() => onDelete(id)} className="text-gray-500 hover:text-red-400 transition-colors" title="Delete Node">
                                    <X size={14} />
                                </button>
                            )}
                        </div>
                    </div>
                    
                    {/* Body - Non Movable */}
                    <div className="p-3 space-y-3 cursor-default" onMouseDown={(e) => e.stopPropagation()}>
                        <div className="text-sm font-bold text-gray-200">{label}</div>
                        
                        {type === 'color' && (
                            <input type="color" value={data?.value || '#ffffff'} onChange={(e) => updateData(id, { value: e.target.value })} className="w-full h-10 bg-transparent cursor-pointer border border-zinc-600 rounded" />
                        )}

                        {type === 'youtube' && (
                            <div>
                                <input type="text" placeholder="Paste YouTube Link" className="w-full bg-zinc-900 text-sm p-2 border border-zinc-700 rounded text-gray-300 mb-1" value={data?.value || ''} onChange={(e) => updateData(id, { value: e.target.value })} />
                                <div className="text-[10px] text-gray-500">Supported: youtube.com/watch?v=... or youtu.be/...</div>
                            </div>
                        )}

                        {type === 'mix' && (
                            <div>
                                <select value={data?.blendMode || 'normal'} onChange={(e) => updateData(id, { blendMode: e.target.value })} className="w-full bg-zinc-950 text-sm p-3 border border-zinc-600 rounded text-white font-medium focus:ring-2 focus:ring-blue-500 outline-none cursor-pointer">
                                    <option value="normal">Normal</option>
                                    <option value="multiply">Multiply</option>
                                    <option value="screen">Screen</option>
                                    <option value="overlay">Overlay</option>
                                    <option value="darken">Darken</option>
                                    <option value="lighten">Lighten</option>
                                    <option value="difference">Difference</option>
                                    <option value="add">Add</option>
                                </select>
                            </div>
                        )}
                        
                        {(type === 'image' || type === 'video') && (
                            <div className="space-y-2">
                                <div className="w-full h-24 bg-black border border-zinc-700 rounded overflow-hidden flex items-center justify-center relative group">
                                    {data?.value ? (
                                        type === 'video' ? <video src={data.value} className="w-full h-full object-cover" muted /> : <img src={data.value} className="w-full h-full object-cover" />
                                    ) : (
                                        <div className="text-gray-600 flex flex-col items-center"><Upload size={24}/></div>
                                    )}
                                    <button onClick={() => fileInputRef.current.click()} className="absolute inset-0 bg-black/50 opacity-0 group-hover:opacity-100 flex items-center justify-center text-sm transition-opacity font-bold">
                                        <Upload size={16} className="mr-2"/> Load Media
                                    </button>
                                </div>
                                <input type="file" ref={fileInputRef} className="hidden" accept={type === 'video' ? "video/*" : "image/*"} onChange={handleFile} />
                            </div>
                        )}

                        {isMedia && (
                            <div className="border-t border-zinc-700 pt-3 mt-2">
                                <div className="flex justify-between items-center mb-2">
                                    <label className="text-xs text-gray-400 font-bold">Fit Mode</label>
                                    <select value={data?.fit || 'fill'} onChange={(e) => updateData(id, { fit: e.target.value })} className="bg-zinc-900 text-xs p-1 px-2 border border-zinc-700 rounded text-gray-300 w-24">
                                        <option value="fill">Stretch</option>
                                        <option value="cover">Crop</option>
                                        <option value="contain">Fit</option>
                                    </select>
                                </div>
                                {data?.fit === 'cover' && (
                                    <div className="grid grid-cols-2 gap-2 mt-2">
                                         <div className="col-span-2">
                                            <label className="text-[10px] text-gray-500 block mb-1">Scale: {data?.scale || 1}x</label>
                                            <input type="range" min="1" max="5" step="0.1" value={data?.scale ?? 1} onChange={(e) => updateData(id, { scale: parseFloat(e.target.value) })} className="w-full h-2 bg-zinc-600 rounded appearance-none cursor-pointer" />
                                         </div>
                                         <div>
                                            <label className="text-[10px] text-gray-500 block mb-1">Pan X: {data?.panX ?? 50}%</label>
                                            <input type="range" min="0" max="100" step="1" value={data?.panX ?? 50} onChange={(e) => updateData(id, { panX: parseFloat(e.target.value) })} className="w-full h-2 bg-zinc-600 rounded appearance-none cursor-pointer" />
                                         </div>
                                         <div>
                                            <label className="text-[10px] text-gray-500 block mb-1">Pan Y: {data?.panY ?? 50}%</label>
                                            <input type="range" min="0" max="100" step="1" value={data?.panY ?? 50} onChange={(e) => updateData(id, { panY: parseFloat(e.target.value) })} className="w-full h-2 bg-zinc-600 rounded appearance-none cursor-pointer" />
                                         </div>
                                         <div className="col-span-2 pt-2 border-t border-zinc-700/50">
                                            <label className="text-[10px] text-gray-500 block mb-1">Stretch X: {data?.stretchX || 1}x</label>
                                            <input type="range" min="0.1" max="3" step="0.05" value={data?.stretchX ?? 1} onChange={(e) => updateData(id, { stretchX: parseFloat(e.target.value) })} className="w-full h-2 bg-zinc-600 rounded appearance-none cursor-pointer" />
                                         </div>
                                          <div className="col-span-2">
                                            <label className="text-[10px] text-gray-500 block mb-1">Stretch Y: {data?.stretchY || 1}x</label>
                                            <input type="range" min="0.1" max="3" step="0.05" value={data?.stretchY ?? 1} onChange={(e) => updateData(id, { stretchY: parseFloat(e.target.value) })} className="w-full h-2 bg-zinc-600 rounded appearance-none cursor-pointer" />
                                         </div>
                                    </div>
                                )}
                            </div>
                        )}

                        {isGenerator && (
                             <div className="border-t border-zinc-700 pt-3 mt-2 space-y-2">
                                <div className="flex justify-between items-center">
                                    <label className="text-xs text-gray-400 font-bold">Noise Type</label>
                                    <select value={data?.noiseType || 'perlin'} onChange={(e) => updateData(id, { noiseType: e.target.value })} className="bg-zinc-900 text-xs p-1 px-2 border border-zinc-700 rounded text-gray-300 w-24">
                                        <option value="perlin">Perlin (Soft)</option>
                                        <option value="fbm">Clouds (FBM)</option>
                                        <option value="ridge">Electricity (Ridge)</option>
                                        <option value="worley">Bubbles (Voronoi)</option>
                                        <option value="cells">Cells (Voronoi ID)</option>
                                    </select>
                                </div>
                                <div>
                                    <label className="text-[10px] text-gray-500 block mb-1">Scale: {data?.scale || 5}</label>
                                    <input type="range" min="1" max="100" step="0.5" value={data?.scale ?? 5} onChange={(e) => updateData(id, { scale: parseFloat(e.target.value) })} className="w-full h-2 bg-zinc-600 rounded appearance-none cursor-pointer" />
                                </div>
                                <div>
                                    <label className="text-[10px] text-gray-500 block mb-1">{data?.noiseType === 'fbm' ? 'Octaves' : 'Detail'}: {data?.detail || 4}</label>
                                    <input type="range" min="1" max={data?.noiseType === 'fbm' ? 8 : 10} step={data?.noiseType === 'fbm' ? 1 : 0.5} value={data?.detail ?? 4} onChange={(e) => updateData(id, { detail: parseFloat(e.target.value) })} className="w-full h-2 bg-zinc-600 rounded appearance-none cursor-pointer" />
                                </div>
                                <div>
                                    <label className="text-[10px] text-gray-500 block mb-1">Distortion: {data?.distortion || 0}</label>
                                    <input type="range" min="0" max="5" step="0.1" value={data?.distortion ?? 0} onChange={(e) => updateData(id, { distortion: parseFloat(e.target.value) })} className="w-full h-2 bg-zinc-600 rounded appearance-none cursor-pointer" />
                                </div>
                                <div className="pt-2 border-t border-zinc-700/50">
                                    <div className="flex items-center justify-between">
                                        <label className="text-xs text-gray-400 font-bold">Animate</label>
                                        <input type="checkbox" checked={data?.isAnimating ?? false} onChange={(e) => updateData(id, { isAnimating: e.target.checked })} className="form-checkbox h-4 w-4 text-blue-600 bg-zinc-800 border-zinc-600 rounded focus:ring-blue-500" />
                                    </div>
                                    {data?.isAnimating ? (
                                        <>
                                            <label className="text-[10px] text-gray-500 block mb-1 mt-2">Animation Speed: {data?.animSpeed || 0.1}</label>
                                            <input type="range" min="0" max="1" step="0.01" value={data?.animSpeed ?? 0.1} onChange={(e) => updateData(id, { animSpeed: parseFloat(e.target.value) })} className="w-full h-2 bg-zinc-600 rounded appearance-none cursor-pointer" />
                                        </>
                                    ) : (
                                        <>
                                            <label className="text-[10px] text-gray-500 block mb-1 mt-2">Time</label>
                                            <input type="range" min="0" max="100" step="0.1" value={data?.time ?? 0} onChange={(e) => updateData(id, { time: parseFloat(e.target.value) })} className="w-full h-2 bg-zinc-600 rounded appearance-none cursor-pointer" />
                                        </>
                                    )}
                                </div>
                            </div>
                        )}

                    </div>
                    
                    {/* Handles - Rendered relative to node content */}
                    {!isOutput && <HandleCircle type="output" title="Output" top={50} active={isConnecting && activeConnectionId === id} onClick={(e) => { e.stopPropagation(); onHandleClick(id, 'output'); }} />}
                    {isOutput && <HandleCircle type="input" title="Input" top={50} onClick={(e) => { e.stopPropagation(); onHandleClick(id, 'input'); }} />}
                    
                    {isMix && (
                        <>
                            <HandleCircle type="base" title="Base Layer" top={50} onClick={(e) => { e.stopPropagation(); onHandleClick(id, 'base'); }} />
                            <HandleCircle type="blend" title="Blend Layer" top={90} onClick={(e) => { e.stopPropagation(); onHandleClick(id, 'blend'); }} />
                            <span className="absolute -left-12 top-[54px] text-[10px] text-gray-400 pointer-events-none w-8 text-right font-bold">Base</span>
                            <span className="absolute -left-12 top-[94px] text-[10px] text-gray-400 pointer-events-none w-8 text-right font-bold">Blend</span>
                        </>
                    )}
                </div>
            );
        };

        const NodeEditor = ({ activeSelection, currentCue, updateCueData, walls, setWalls }) => {
            const [nodes, setNodes] = useState([]);
            const [connections, setConnections] = useState([]);
            const [pan, setPan] = useState({ x: 0, y: 0 });
            const [zoom, setZoom] = useState(1);
            const [draggingId, setDraggingId] = useState(null);
            const dragOffset = useRef({ x: 0, y: 0 });
            const [connectSource, setConnectSource] = useState(null); // { id, handle }
            const [contextMenu, setContextMenu] = useState(null);
            const [hoveredConnectionIndex, setHoveredConnectionIndex] = useState(null);

            useEffect(() => {
                let animationFrameId;
                const animateNodes = () => {
                    setNodes(currentNodes => currentNodes.map(n => {
                        if (n.type === 'noise' && n.data.isAnimating) {
                            const newTime = (n.data.time || 0) + (n.data.animSpeed || 0.1);
                            return { ...n, data: { ...n.data, time: newTime } };
                        }
                        return n;
                    }));
                    animationFrameId = requestAnimationFrame(animateNodes);
                };
                animationFrameId = requestAnimationFrame(animateNodes);
                return () => cancelAnimationFrame(animationFrameId);
            }, []);

            useEffect(() => {
                if(currentCue) {
                    if(activeSelection.type === 'transition') {
                        setNodes([ { id: 'n1', type: 'state', x: 50, y: 100, label: 'Prev Cue' }, { id: 'n2', type: 'effect', x: 300, y: 100, label: 'Crossfade' }, { id: 'n3', type: 'state', x: 600, y: 100, label: 'Next Cue' } ]);
                        setConnections([{ from: 'n1', to: 'n2' }, { from: 'n2', to: 'n3' }]);
                    } else {
                        if(currentCue.nodes && currentCue.nodes.length > 0) {
                            setNodes(currentCue.nodes);
                            setConnections(currentCue.connections);
                            const existingWallIds = new Set(currentCue.nodes.filter(n => n.type === 'output').map(n => n.data.wallId));
                            const missingWalls = walls.filter(w => !existingWallIds.has(w.id));
                            if(missingWalls.length > 0) {
                                const newNodes = missingWalls.map((w, i) => ({ id: `wall-${w.id}`, type: 'output', x: 800, y: 50 + ((currentCue.nodes.length + i) * 150), label: w.name, data: { wallId: w.id } }));
                                setNodes(prev => [...prev, ...newNodes]);
                            }
                        } else {
                            const newNodes = walls.map((w, i) => ({ id: `wall-${w.id}`, type: 'output', x: 800, y: 50 + (i * 200), label: w.name, data: { wallId: w.id } }));
                            setNodes(newNodes);
                            setConnections([]);
                        }
                    }
                }
            }, [activeSelection.cueId, activeSelection.type, walls.length]); 

            useEffect(() => {
                if(activeSelection.type === 'cue' && nodes.length > 0) {
                    updateCueData({ nodes, connections });
                }
            }, [nodes, connections]);

            const handleDragStart = (e, id) => {
                e.stopPropagation();
                const node = nodes.find(n => n.id === id);
                dragOffset.current = { x: e.clientX - node.x * zoom - pan.x, y: e.clientY - node.y * zoom - pan.y };
                setDraggingId(id);
                setConnectSource(null); // Cancel connection if dragging starts
            };

            const handleHandleClick = (id, handleType) => {
                if(handleType === 'output') {
                    // Clicked Output
                    if(connectSource?.id === id && connectSource?.handle === 'output') {
                        setConnectSource(null); // toggle off
                    } else {
                        setConnectSource({ id, handle: 'output' });
                    }
                } else {
                    // Clicked Input
                    if(connectSource && connectSource.handle === 'output') {
                        if(connectSource.id !== id) {
                            // Create connection
                            const filtered = connections.filter(c => !(c.to === id && c.toHandle === handleType));
                            setConnections([...filtered, { from: connectSource.id, to: id, toHandle: handleType }]);
                            setConnectSource(null);
                        }
                    }
                }
            };

            const handleMouseMove = (e) => {
                if (draggingId) {
                    const newX = (e.clientX - pan.x - dragOffset.current.x) / zoom;
                    const newY = (e.clientY - pan.y - dragOffset.current.y) / zoom;
                    setNodes(prev => prev.map(n => n.id === draggingId ? { ...n, x: newX, y: newY } : n));
                } else if (e.buttons === 4 || (e.buttons === 1 && e.shiftKey)) {
                    setPan(p => ({ x: p.x + e.movementX, y: p.y + e.movementY }));
                }
            };

            const handleMouseUp = () => setDraggingId(null);
            const handleBgClick = () => { setConnectSource(null); setContextMenu(null); };
            
            const handleWheel = (e) => {
                if (e.ctrlKey) {
                    setZoom(z => Math.min(Math.max(z - e.deltaY * 0.001, 0.5), 2));
                } else {
                    setPan(p => ({ x: p.x - e.deltaX, y: p.y - e.deltaY }));
                }
            };

            const handleContextMenu = (e) => { e.preventDefault(); setContextMenu({ x: e.clientX, y: e.clientY }); };
            
            const addNode = (type, label) => { 
                const id = `n-${Date.now()}`; 
                const centerX = (window.innerWidth / 2 - pan.x) / zoom - 300; 
                const centerY = (200 - pan.y) / zoom; 
                setNodes(prev => [...prev, { id, type, x: centerX, y: centerY, label, data: type === 'color' ? { value: '#ffffff' } : type === 'noise' ? { noiseType: 'fbm', scale: 5, detail: 4, time: 0, distortion: 0, isAnimating: true, animSpeed: 0.05 } : type === 'image' || type === 'video' ? { fit: 'cover', scale: 1, panX: 50, panY: 50, stretchX: 1, stretchY: 1 } : {} }]); 
                setContextMenu(null); 
            };
            
            const handleAddImageNode = () => { addNode('image', 'Image Source'); };
            const updateNodeData = (id, data) => { setNodes(prev => prev.map(n => n.id === id ? { ...n, data: { ...n.data, ...data } } : n)); };
            const deleteConnection = (index) => { setConnections(prev => prev.filter((_, i) => i !== index)); };
            
            const deleteNode = (idToDelete) => {
                const nodeToDelete = nodes.find(n => n.id === idToDelete);
                if (!nodeToDelete) return;

                // Prevent deleting any wall output node
                if (nodeToDelete.type === 'output') {
                    alert("Cannot delete an output node. To remove a wall, delete it from the Geometry panel.");
                    return;
                }

                setNodes(prev => prev.filter(n => n.id !== idToDelete));
                setConnections(prev => prev.filter(c => c.from !== idToDelete && c.to !== idToDelete));
            };

            // REPLACE the existing getHandleOffset function with this updated version
            const getHandleOffset = (node, handle) => {
                if (!node) return { x: 0, y: 0 };
                
                // Standard width of the node card
                const width = 256; 

                // Output handles (Right side)
                if (handle === 'output') return { x: node.x + width + 8, y: node.y + 64 };
                
                // Wall Nodes (Output type) input handle
                if (node.type === 'output') return { x: node.x - 8, y: node.y + 64 };

                // Mix Node handles
                if (handle === 'base') return { x: node.x - 8, y: node.y + 64 };
                if (handle === 'blend') return { x: node.x - 8, y: node.y + 104 };

                // Default for single inputs (Image, Video, etc.)
                return { x: node.x - 8, y: node.y + 64 };
            };

            const getBezierMidpoint = (p0, p1, p2, p3) => {
                 const t = 0.5;
                 const x = (1-t)*(1-t)*(1-t)*p0.x + 3*(1-t)*(1-t)*t*p1.x + 3*(1-t)*t*t*p2.x + t*t*t*p3.x;
                 const y = (1-t)*(1-t)*(1-t)*p0.y + 3*(1-t)*(1-t)*t*p1.y + 3*(1-t)*t*t*p2.y + t*t*t*p3.y;
                 return {x, y};
            };

            return (
                <div className="h-full bg-transparent relative overflow-hidden select-none" onMouseMove={handleMouseMove} onMouseUp={handleMouseUp} onMouseLeave={handleMouseUp} onWheel={handleWheel} onContextMenu={handleContextMenu} onClick={handleBgClick}>
                    <div className="absolute inset-0 node-grid opacity-30" style={{ transform: `translate(${pan.x}px, ${pan.y}px) scale(${zoom})`, transformOrigin: '0 0' }}></div>
                    <div className="absolute top-2 left-2 z-10 flex gap-2 pointer-events-none">
                        <div className="bg-zinc-800/80 backdrop-blur border border-zinc-700 rounded p-2 flex items-center gap-2 shadow-lg pointer-events-auto">
                            <Workflow size={14} className="text-purple-400" />
                            <span className="text-xs font-bold text-gray-300">{activeSelection.type === 'transition' ? 'Transition Logic' : 'Content Graph'}</span>
                            {activeSelection.type === 'cue' && (
                                <>
                                    <div className="w-px h-4 bg-zinc-600 mx-1"></div>
                                    <button onClick={handleAddImageNode} className="flex items-center gap-1 bg-purple-700 hover:bg-purple-600 text-white text-[10px] px-2 py-1 rounded transition-colors"> <Plus size={10}/> Add Image </button>
                                    <button onClick={() => addNode('video', 'Video')} className="flex items-center gap-1 bg-pink-700 hover:bg-pink-600 text-white text-[10px] px-2 py-1 rounded transition-colors"> <Video size={10}/> Add Video </button>
                                    <button onClick={() => addNode('color', 'Color')} className="flex items-center gap-1 bg-sky-700 hover:bg-sky-600 text-white text-[10px] px-2 py-1 rounded transition-colors"> <Palette size={10}/> Add Color </button>
                                    <button onClick={() => addNode('mix', 'Mixer')} className="flex items-center gap-1 bg-orange-700 hover:bg-orange-600 text-white text-[10px] px-2 py-1 rounded transition-colors"> <Blend size={10}/> Add Mix </button>
                                    <button onClick={() => addNode('noise', 'Noise')} className="flex items-center gap-1 bg-teal-700 hover:bg-teal-600 text-white text-[10px] px-2 py-1 rounded transition-colors"> <Activity size={10}/> Add Noise </button>
                                    <div className="text-[10px] text-gray-500 ml-2">Click handles to connect</div>
                                </>
                            )}
                        </div>
                    </div>
                    {contextMenu && activeSelection.type === 'cue' && (
                        <div className="absolute z-50 bg-zinc-800 border border-zinc-600 rounded shadow-xl py-1 w-32" style={{top: contextMenu.y - 40, left: contextMenu.x}}>
                            <div className="px-2 py-1 text-[10px] text-gray-500 font-bold uppercase">Add Node</div>
                            <button onClick={() => addNode('image', 'Image Source')} className="w-full text-left px-3 py-1.5 text-xs text-white hover:bg-purple-600 flex gap-2"><ImageIcon size={12}/> Image</button>
                            <button onClick={() => addNode('video', 'Video Source')} className="w-full text-left px-3 py-1.5 text-xs text-white hover:bg-purple-600 flex gap-2"><Video size={12}/> Video</button>
                            <button onClick={() => addNode('youtube', 'YouTube')} className="w-full text-left px-3 py-1.5 text-xs text-white hover:bg-purple-600 flex gap-2"><Youtube size={12}/> YouTube</button>
                            <button onClick={() => addNode('color', 'Color Source')} className="w-full text-left px-3 py-1.5 text-xs text-white hover:bg-purple-600 flex gap-2"><Palette size={12}/> Color</button>
                            <button onClick={() => addNode('noise', 'Noise Generator')} className="w-full text-left px-3 py-1.5 text-xs text-white hover:bg-purple-600 flex gap-2"><Activity size={12}/> Noise</button>
                            <div className="w-full h-px bg-zinc-700 my-1"></div>
                            <button onClick={() => addNode('mix', 'Mix / Mask')} className="w-full text-left px-3 py-1.5 text-xs text-white hover:bg-orange-600 flex gap-2"><Blend size={12}/> Mixer</button>
                        </div>
                    )}
                    <div style={{ transform: `translate(${pan.x}px, ${pan.y}px) scale(${zoom})`, transformOrigin: '0 0', width: '100%', height: '100%' }}>
                        <svg className="absolute inset-0 overflow-visible pointer-events-auto">
                            {connections.map((conn, i) => {
                                const fromNode = nodes.find(n => n.id === conn.from);
                                const toNode = nodes.find(n => n.id === conn.to);
                                if(!fromNode || !toNode) return null;
                                
                                const start = getHandleOffset(fromNode, 'output');
                                const end = getHandleOffset(toNode, conn.toHandle || 'input'); 

                                const cp1x = start.x + (end.x - start.x) / 2; 
                                const cp2x = end.x - (end.x - start.x) / 2;
                                
                                const isHovered = hoveredConnectionIndex === i;
                                const mid = getBezierMidpoint({x:start.x, y:start.y}, {x:cp1x, y:start.y}, {x:cp2x, y:end.y}, {x:end.x, y:end.y});

                                return (
                                    <g key={i} onMouseEnter={() => setHoveredConnectionIndex(i)} onMouseLeave={() => setHoveredConnectionIndex(null)}>
                                        <path d={`M ${start.x} ${start.y} C ${cp1x} ${start.y}, ${cp2x} ${end.y}, ${end.x} ${end.y}`} fill="none" stroke="transparent" strokeWidth="20" />
                                        <path d={`M ${start.x} ${start.y} C ${cp1x} ${start.y}, ${cp2x} ${end.y}, ${end.x} ${end.y}`} fill="none" stroke={isHovered ? "#ef4444" : "#555"} strokeWidth="2" />
                                        {isHovered && (
                                            <foreignObject x={mid.x - 12} y={mid.y - 12} width="24" height="24" className="overflow-visible">
                                                <div 
                                                    className="w-6 h-6 bg-red-600 rounded-full flex items-center justify-center cursor-pointer hover:scale-125 transition-transform shadow-lg"
                                                    onClick={(e) => { e.stopPropagation(); deleteConnection(i); }}
                                                    title="Remove Connection"
                                                >
                                                    <Trash2 size={12} className="text-white"/>
                                                </div>
                                            </foreignObject>
                                        )}
                                    </g>
                                );
                            })}
                            {connectSource && (
                                (() => {
                                    const fromNode = nodes.find(n => n.id === connectSource.id);
                                    if(fromNode) {
                                        const start = getHandleOffset(fromNode, 'output');
                                        return <circle cx={start.x} cy={start.y} r="4" fill="white" />;
                                    }
                                })()
                            )}
                        </svg>
                        {nodes.map(node => ( <div key={node.id}><Node id={node.id} {...node} selected={draggingId === node.id} isConnecting={!!connectSource} activeConnectionId={connectSource?.id} onDragStart={handleDragStart} onHandleClick={handleHandleClick} updateData={updateNodeData} onDelete={deleteNode} /></div>))}
                    </div>
                </div>
            );
        };

        const FolderItem = ({ folder, walls, activeWallId, setActiveWallId, setWalls, setFolders }) => {
            const folderWalls = walls.filter(w => w.folderId === folder.id);
            return (
                <div className="mb-2">
                    <div className="flex items-center gap-2 p-2 bg-zinc-800 hover:bg-zinc-700 rounded cursor-pointer text-xs font-bold text-gray-300" onClick={() => setFolders(prev => prev.map(f => f.id === folder.id ? {...f, isOpen: !f.isOpen} : f))}>
                        {folder.isOpen ? <ChevronDown size={14}/> : <ChevronRight size={14}/>} <Folder size={14} className="text-blue-400" /> {folder.name} <span className="ml-auto text-[10px] text-gray-500">{folderWalls.length}</span>
                        <button onClick={(e) => {e.stopPropagation(); setFolders(prev => prev.filter(f => f.id !== folder.id)); setWalls(prev => prev.map(w => w.folderId === folder.id ? {...w, folderId: null} : w))}} className="text-gray-500 hover:text-red-400 ml-2"><Trash2 size={12}/></button>
                    </div>
                    {folder.isOpen && (
                        <div className="ml-2 pl-2 border-l border-zinc-700 mt-1 space-y-1">
                            {folderWalls.map(wall => (
                                <div key={wall.id} onClick={() => setActiveWallId(wall.id)} className={`flex justify-between items-center p-2 rounded text-xs cursor-pointer ${wall.id === activeWallId ? 'bg-zinc-700 text-white border border-zinc-600' : 'text-gray-400 hover:bg-zinc-800/50'}`}>
                                    <div className="flex items-center gap-2"><div className="w-2 h-2 rounded-full" style={{ backgroundColor: wall.color }}></div>{wall.name}</div>
                                    <button onClick={(e) => {e.stopPropagation(); setWalls(p => p.filter(w => w.id !== wall.id))}} className="hover:text-red-400"><Trash2 size={12}/></button>
                                </div>
                            ))}
                            {folderWalls.length === 0 && <div className="text-[10px] text-gray-600 p-2 italic">Empty Folder</div>}
                        </div>
                    )}
                </div>
            );
        };

        const App = () => {
            const [walls, setWalls] = useState([{ id: 1, name: "Anchor Wall", width: 3.0, height: 1.69, color: "#84cc16", isCalibrationTarget: true, folderId: null, pos: {x: 0, y: 0, z: 0}, rot: {x: 0, y: 0, z: 0}, points: [{ x: 100, y: 100 }, { x: 500, y: 100 }, { x: 500, y: 325 }, { x: 100, y: 325 }] }]);
            const [folders, setFolders] = useState([]); 
            const [activeWallId, setActiveWallId] = useState(1);
            const [menuOpen, setMenuOpen] = useState(false);
            const [viewMode, setViewMode] = useState('2d'); 
            const [showGuides, setShowGuides] = useState(false); 
            const [showTexture, setShowTexture] = useState(true); 
            const [moveMode, setMoveMode] = useState(false);
            const [pose, setPose] = useState(null);
            const [throwRatio, setThrowRatio] = useState(1.2);
            const [calibrationSuccess, setCalibrationSuccess] = useState(false);
            const fileInputRef = useRef(null);
            const [isFullscreen, setIsFullscreen] = useState(false);
            const [showNodeEditor, setShowNodeEditor] = useState(true);
            const [storageUsage, setStorageUsage] = useState(null);
            
            // --- SCENE & TRANSITION STATE ---
            const [menuTab, setMenuTab] = useState('config'); 
            const [scenes, setScenes] = useState([{ id: 1, name: "Act 1", cues: [{ id: 1, name: "Cue 1 (Intro)", type: 'standard', transitionDuration: 1.0, animationType: 'static', nodes: null, connections: null }] }]);
            const [activeState, setActiveState] = useState({ sceneId: 1, cueId: 1 });
            const [activeSelection, setActiveSelection] = useState({ type: 'cue', sceneId: 1, cueId: 1 });
            
            // Engine States
            const [transitionProgress, setTransitionProgress] = useState(1);
            const [prevCueState, setPrevCueState] = useState(null);
            const [currentCueState, setCurrentCueState] = useState(null);
            const requestRef = useRef();
            const startTimeRef = useRef();
            const saveTimeoutRef = useRef();

            // Load Data on Startup
            useEffect(() => {
                const loadData = async () => {
                    try {
                        const savedState = await db.loadState('project_data_v22');
                        if (savedState) {
                            setWalls(savedState.walls || []);
                            setFolders(savedState.folders || []);
                            setPose(savedState.pose);
                            
                            // Restore Asset URLs in Scenes
                            const restoredScenes = await Promise.all(savedState.scenes.map(async (scene) => {
                                const restoredCues = await Promise.all(scene.cues.map(async (cue) => {
                                    // Restore nodes assets
                                    if(cue.nodes) {
                                        cue.nodes = await Promise.all(cue.nodes.map(async (n) => {
                                            if (n.data?.assetId) {
                                                const blob = await db.getAsset(n.data.assetId);
                                                if(blob) n.data.value = URL.createObjectURL(blob);
                                            }
                                            return n;
                                        }));
                                    }
                                    return cue;
                                }));
                                return { ...scene, cues: restoredCues };
                            }));
                            setScenes(restoredScenes);
                        }
                        const usage = await db.getUsage();
                        setStorageUsage(usage);
                    } catch (e) {
                        console.error("Failed to load state", e);
                    }
                };
                loadData();
            }, []);

            // Auto-Save Effect
            useEffect(() => {
                if (saveTimeoutRef.current) clearTimeout(saveTimeoutRef.current);
                saveTimeoutRef.current = setTimeout(async () => {
                    await db.saveState('project_data_v22', { walls, folders, scenes, pose });
                    const usage = await db.getUsage();
                    setStorageUsage(usage);
                }, 1000); // Debounce 1s
                return () => clearTimeout(saveTimeoutRef.current);
            }, [walls, folders, scenes, pose]);

            useEffect(() => {
                const handleFsChange = () => setIsFullscreen(!!document.fullscreenElement);
                document.addEventListener('fullscreenchange', handleFsChange);
                return () => document.removeEventListener('fullscreenchange', handleFsChange);
            }, []);

            const enterFullscreen = () => { document.documentElement.requestFullscreen().catch(e => console.log(e)); };
            const sortedWalls = useMemo(() => [...walls].sort((a, b) => a.pos.z - b.pos.z), [walls]);
            const getCueData = (sId, cId) => { const s = scenes.find(x => x.id === sId); return s ? s.cues.find(x => x.id === cId) : null; };
            const targetCueId = activeSelection.type === 'cue' ? activeSelection.cueId : activeSelection.nextCueId;
            const currentCueObj = useMemo(() => getCueData(activeSelection.sceneId, targetCueId), [activeSelection, scenes]);

            const updateCueData = (newData) => {
                setScenes(prev => prev.map(s => {
                    if(s.id !== activeSelection.sceneId) return s;
                    return { ...s, cues: s.cues.map(c => { if(c.id !== targetCueId) return c; return { ...c, ...newData }; }) }
                }));
            };

            const animateTransition = (time) => {
                if (!startTimeRef.current) startTimeRef.current = time;
                const duration = (currentCueObj?.transitionDuration || 0) * 1000; 
                const elapsed = time - startTimeRef.current;
                let progress = duration > 0 ? Math.min(elapsed / duration, 1) : 1;
                setTransitionProgress(progress);
                if (progress < 1) { requestRef.current = requestAnimationFrame(animateTransition); }
            };

            useEffect(() => {
                if (currentCueObj) { setPrevCueState(currentCueState); setCurrentCueState(currentCueObj); startTimeRef.current = null; cancelAnimationFrame(requestRef.current); requestRef.current = requestAnimationFrame(animateTransition); }
                return () => cancelAnimationFrame(requestRef.current);
            }, [targetCueId, activeSelection.sceneId]); 

            useEffect(() => { if (activeSelection.type === 'cue') setCurrentCueState(currentCueObj); }, [scenes]); 

            useEffect(() => {
                const handleKeyDown = (e) => { 
                    const k = e.key.toLowerCase();
                    if (k === 'h') { if (viewMode === 'live') { setViewMode('2d'); setMenuOpen(true); } else { setMenuOpen(p => !p); } }
                    if (k === 'm' && viewMode !== 'live') setShowGuides(p => !p); 
                    if (k === 't' && viewMode === '2d') setShowTexture(p => !p); 
                    if (k === 'w' && viewMode === '2d') setMoveMode(p => !p);
                    if (k === 'z' || k === 'v') navigateCue(k === 'z' ? 1 : -1);
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [viewMode, activeState, scenes]);

            const navigateCue = (direction) => {
                let flatList = [];
                scenes.forEach(s => { s.cues.forEach(c => { flatList.push({ sceneId: s.id, cueId: c.id }); }); });
                const currentIndex = flatList.findIndex(i => i.sceneId === activeSelection.sceneId && i.cueId === targetCueId);
                if (currentIndex === -1) return;
                let nextIndex = currentIndex + direction;
                if (nextIndex >= 0 && nextIndex < flatList.length) { setActiveSelection({ type: 'cue', ...flatList[nextIndex] }); }
            };

            const updatePoint = (wallId, pointIndex, cx, cy) => { setWalls(prev => prev.map(w => { if (w.id !== wallId) return w; const currentPoints = [...w.points]; if (moveMode) { const prevX = currentPoints[pointIndex].x; const prevY = currentPoints[pointIndex].y; const dx = cx - prevX; const dy = cy - prevY; const newPoints = currentPoints.map(p => ({ x: p.x + dx, y: p.y + dy })); return { ...w, points: newPoints }; } else { currentPoints[pointIndex] = { x: cx, y: cy }; return { ...w, points: currentPoints }; } })); };
            const updateTransform = (wallId, type, axis, val) => { setWalls(prev => prev.map(w => w.id !== wallId ? w : { ...w, [type]: { ...w[type], [axis]: parseFloat(val) || 0 } })); };
            const calibrate = () => { const anchor = walls.find(w => w.isCalibrationTarget); if (!anchor) return; const halfW = anchor.width / 2; const halfH = anchor.height / 2; const worldPoints = [{ x: -halfW, y: halfH }, { x: halfW, y: halfH }, { x: halfW, y: -halfH }, { x: -halfW, y: -halfH }]; const H_raw = solveHomography(worldPoints, anchor.points); const anchorResult = decomposeHomographyWithIntrinsics(H_raw, throwRatio, window.innerWidth, window.innerHeight); setPose(anchorResult); const newWalls = walls.map(wall => { if (wall.isCalibrationTarget) return wall; const wHalfW = wall.width / 2; const wHalfH = wall.height / 2; const wWorldPoints = [{ x: -wHalfW, y: wHalfH }, { x: wHalfW, y: wHalfH }, { x: wHalfW, y: -wHalfH }, { x: -wHalfW, y: -wHalfH }]; const H_wall = solveHomography(wWorldPoints, wall.points); const wallResult = decomposeHomographyWithIntrinsics(H_wall, throwRatio, window.innerWidth, window.innerHeight); const T_cam_to_anchor = anchorResult.camToWorldMatrix; const T_wall_to_cam = wallResult.worldToCamMatrix; const T_wall_to_anchor = T_cam_to_anchor.clone().multiply(T_wall_to_cam); const pos = new THREE.Vector3(); const quat = new THREE.Quaternion(); const scale = new THREE.Vector3(); T_wall_to_anchor.decompose(pos, quat, scale); const euler = new THREE.Euler().setFromQuaternion(quat); return { ...wall, pos: { x: pos.x, y: pos.y, z: pos.z }, rot: { x: THREE.MathUtils.radToDeg(euler.x), y: THREE.MathUtils.radToDeg(euler.y), z: THREE.MathUtils.radToDeg(euler.z) } }; }); setWalls(newWalls); setCalibrationSuccess(true); setTimeout(() => setCalibrationSuccess(false), 2000); };
            const addFolder = () => { const newId = Math.max(0, ...folders.map(f => f.id)) + 1; setFolders(prev => [...prev, {id: newId, name: `Group ${newId}`, isOpen: true}]); };
            const addScene = () => { const newId = Math.max(0, ...scenes.map(s => s.id)) + 1; setScenes(prev => [...prev, { id: newId, name: `Act ${newId}`, cues: [{ id: 1, name: "Cue 1", type: 'standard' }] }]); };
            const addCue = (sceneId) => { setScenes(prev => prev.map(s => { if (s.id !== sceneId) return s; const newCueId = Math.max(0, ...s.cues.map(c => c.id)) + 1; return { ...s, cues: [...s.cues, { id: newCueId, name: `Cue ${newCueId}`, type: 'standard' }] }; })); };
            const resetData = async () => { if(confirm("This will delete all saved data and images. Are you sure?")) { await db.clearAll(); window.location.reload(); } };

            const activeWall = walls.find(w => w.id === activeWallId);

            // --- RENDERER with TRANSITION LOGIC ---
            const renderSVG = (isLive) => (
                <svg className="w-full h-full" style={{backgroundColor: (showTexture || isLive) ? 'black' : 'transparent'}}>
                    {/* ... (SVG Defs and Grid Patterns omitted for brevity but present in rendering) ... */}
                    <defs>
                         <pattern id="smallGrid" width="20" height="20" patternUnits="userSpaceOnUse"><path d="M 20 0 L 0 0 0 20" fill="none" stroke="rgba(255,255,255,0.1)" strokeWidth="0.5"/></pattern>
                         <pattern id="grid" width="100" height="100" patternUnits="userSpaceOnUse"><rect width="100" height="100" fill="url(#smallGrid)"/><path d="M 100 0 L 0 0 0 100" fill="none" stroke="rgba(255,255,255,0.2)" strokeWidth="1"/></pattern>
                    </defs>
                    {showGuides && !isLive && (<><rect width="100%" height="100%" fill="url(#grid)" pointerEvents="none" /><line x1="50%" y1="0" x2="50%" y2="100%" stroke="cyan" strokeOpacity="0.5" strokeDasharray="5,5" pointerEvents="none" /><line x1="0" y1="50%" x2="100%" y2="50%" stroke="cyan" strokeOpacity="0.5" strokeDasharray="5,5" pointerEvents="none" /></>)}
                    {sortedWalls.map(wall => {
                        const getWallStyle = (cueState) => {
                            if (!cueState) return { fill: wall.color, stroke: isLive ? 'none' : wall.color };
                            return { fill: wall.color, stroke: isLive ? 'none' : wall.color };
                        };
                        const currStyle = getWallStyle(currentCueState);
                        const baseOpacity = isLive ? 1 : (wall.id === activeWallId ? 0.5 : 0.1);
                        
                        const isProjecting = (isLive || showTexture) && currentCueState?.nodes?.some(n => n.type === 'output' && n.data.wallId === wall.id && currentCueState.connections?.some(c => c.to === n.id));
                        
                        return (
                            <g key={wall.id} onClick={(e) => { if(!isLive) { e.stopPropagation(); setActiveWallId(wall.id); }}}>
                                {isProjecting && ( <path d={`M ${wall.points[0].x} ${wall.points[0].y} L ${wall.points[1].x} ${wall.points[1].y} L ${wall.points[2].x} ${wall.points[2].y} L ${wall.points[3].x} ${wall.points[3].y} Z`} fill="transparent" stroke="none" /> )}
                                {!isProjecting && (isLive || showTexture) && ( <path d={`M ${wall.points[0].x} ${wall.points[0].y} L ${wall.points[1].x} ${wall.points[1].y} L ${wall.points[2].x} ${wall.points[2].y} L ${wall.points[3].x} ${wall.points[3].y} Z`} fill={currStyle.fill} fillOpacity={baseOpacity} stroke="none" /> )}
                                {(!isLive && !showTexture) && ( <path d={`M ${wall.points[0].x} ${wall.points[0].y} L ${wall.points[1].x} ${wall.points[1].y} L ${wall.points[2].x} ${wall.points[2].y} L ${wall.points[3].x} ${wall.points[3].y} Z`} fill={currStyle.fill} fillOpacity={baseOpacity} stroke={currStyle.stroke} strokeWidth={wall.id === activeWallId ? 2 : 1} strokeDasharray={wall.isCalibrationTarget ? "0" : "5,5"} /> )}
                                {((isLive && currentCueObj?.type === 'test') || (!isLive && showTexture)) && <WarpedTextureGrid wallPoints={wall.points} />}
                                {(!isLive && (wall.id === activeWallId) && !showTexture) && wall.points.map((p, i) => ( <PointHandle key={`handle-${wall.id}-${i}`} index={i} x={p.x} y={p.y} color={wall.color} isSelected={true} onDrag={(idx, x, y) => updatePoint(wall.id, idx, x, y)} isMoveMode={moveMode} /> ))}
                                {showGuides && !isLive && wall.points.map((p, i) => ( <text key={`guide-lbl-${i}`} x={p.x + 12} y={p.y + 4} fill="lime" fontSize="9" fontFamily="monospace" className="pointer-events-none select-none shadow-black drop-shadow-md" style={{textShadow: '1px 1px 0 #000'}}> {Math.round(p.x)},{Math.round(p.y)} </text> ))}
                                {showGuides && !isLive && ( <g pointerEvents="none"> <line x1={wall.points[0].x} y1={wall.points[0].y} x2={wall.points[2].x} y2={wall.points[2].y} stroke="cyan" strokeWidth="1" strokeOpacity="0.5" strokeDasharray="4,4" /> <line x1={wall.points[1].x} y1={wall.points[1].y} x2={wall.points[3].x} y2={wall.points[3].y} stroke="cyan" strokeWidth="1" strokeOpacity="0.5" strokeDasharray="4,4" /> </g> )}
                            </g>
                        );
                    })}
                    {(!isLive && activeWall && !showTexture) && activeWall.points.map((p, i) => ( <PointHandle key={`handle-${activeWall.id}-${i}`} index={i} x={p.x} y={p.y} color={activeWall.color} isSelected={true} onDrag={(idx, x, y) => updatePoint(activeWall.id, idx, x, y)} isMoveMode={moveMode} /> ))}
                </svg>
            );

            return (
                <div className="w-full h-full relative font-sans text-white bg-zinc-950 flex flex-col">
                    {!isFullscreen && (
                        <div className="absolute inset-0 z-[100] bg-black/80 backdrop-blur-sm flex flex-col items-center justify-center text-center p-8">
                            <div className="max-w-md space-y-6">
                                <h1 className="text-4xl font-bold text-white mb-2">Theater Projection Tool v23.1</h1>
                                <div className="p-4 bg-red-900/30 border border-red-600/50 rounded-lg text-red-200 text-sm flex items-start gap-3 text-left">
                                    <AlertTriangle size={24} className="shrink-0 mt-0.5" />
                                    <div>
                                        <p className="font-bold mb-1">Browser Compatibility</p>
                                        <p>This tool uses advanced 3D rendering which may not work well in Safari. Chrome or Firefox is recommended.</p>
                                    </div>
                                </div>
                                <div className="p-4 bg-yellow-900/30 border border-yellow-600/50 rounded-lg text-yellow-200 text-sm flex items-start gap-3 text-left">
                                    <AlertTriangle size={24} className="shrink-0 mt-0.5" />
                                    <div>
                                        <p className="font-bold mb-1">Optimization Notice</p>
                                        <p>The software has been optimized for the Dvorak layout. QWERTY layout will be coming later.</p>
                                    </div>
                                </div>
                                <p className="text-gray-300">This application works best in full screen mode.</p>
                                <button onClick={enterFullscreen} className="bg-blue-600 hover:bg-blue-500 text-white px-6 py-3 rounded-lg font-bold text-lg transition-transform hover:scale-105 flex items-center justify-center gap-2 mx-auto">
                                    <Maximize size={20} /> Enter Full Screen
                                </button>
                            </div>
                        </div>
                    )}

                    {viewMode !== 'live' && (
                        <div className="absolute top-4 right-4 pointer-events-none select-none z-50 flex flex-col items-end gap-1">
                            <div className="text-[10px] text-gray-400 bg-black/50 px-2 py-1 rounded backdrop-blur">CURRENT</div>
                            <div className="text-xl font-bold text-white drop-shadow-md">{currentCueObj?.name || "No Cue"}</div>
                            <div className="text-xs text-gray-300 bg-purple-900/50 px-2 py-0.5 rounded border border-purple-500/30">
                                {currentCueObj?.type === 'blackout' ? "BLACKOUT" : currentCueObj?.type === 'test' ? "TEST PATTERN" : "STANDARD"}
                            </div>
                        </div>
                    )}

                    <div className={`absolute inset-0 h-full z-0`}>
                        {viewMode === '2d' && (
                            <div className="absolute inset-0 z-10" onClick={() => setActiveWallId(null)}>
                                {(showTexture || viewMode === 'live') && <ProjectedContent cueState={currentCueState} walls={walls} />}
                                {renderSVG(false)}
                                <div className="absolute top-4 left-4 pointer-events-none select-none drop-shadow-md z-50">
                                    <h1 className={`text-xl font-bold tracking-wider ${showTexture ? 'text-zinc-600' : 'text-white'}`}>MAPPING STUDIO</h1>
                                    <div className="flex gap-2 mt-1">
                                        <span className={`text-xs px-1.5 py-0.5 rounded font-mono border transition-colors ${moveMode ? 'bg-orange-600 border-orange-400 text-white' : 'bg-zinc-800 border-zinc-600 text-gray-200'}`}>W: Move All</span>
                                        <span className={`text-xs px-1.5 py-0.5 rounded font-mono border transition-colors ${showTexture ? 'bg-white text-black border-white font-bold' : 'bg-zinc-800 border-zinc-600 text-gray-200'}`}>T: Texture</span>
                                        <span className={`text-xs px-1.5 py-0.5 rounded font-mono border transition-colors ${showGuides ? 'bg-blue-900 border-blue-500 text-blue-100' : 'bg-zinc-800 border-zinc-600 text-gray-200'}`}>M: Guides</span>
                                        <span className="text-xs bg-zinc-800 px-1.5 py-0.5 rounded text-gray-200 font-mono border border-zinc-600">H: Menu</span>
                                    </div>
                                </div>
                            </div>
                        )}
                        {viewMode === 'live' && (
                            <div className="absolute inset-0 z-50 cursor-none bg-black">
                                <ProjectedContent cueState={currentCueState} walls={walls} />
                                {renderSVG(true)}
                            </div>
                        )}
                        {viewMode === '3d' && (
                            <div className="absolute inset-0 z-10">
                                 <Canvas><Scene3D walls={walls} pose={pose} calibrationWall={walls.find(w => w.isCalibrationTarget) || walls[0]} showGuides={showGuides} currentCue={currentCueState} /></Canvas>
                                 <div className="absolute top-4 left-4 pointer-events-none select-none drop-shadow-md z-50"><h1 className="text-xl font-bold text-lime-400">3D SIMULATION</h1></div>
                            </div>
                        )}
                    </div>

                    {menuTab === 'scenes' && viewMode !== 'live' && showNodeEditor && (
                        <div className="absolute bottom-0 left-0 right-0 h-[45%] z-30 border-t border-zinc-700/30 bg-zinc-900/50 backdrop-blur-md">
                            <NodeEditor activeSelection={activeSelection} currentCue={currentCueObj} updateCueData={updateCueData} walls={walls} setWalls={setWalls} />
                        </div>
                    )}

                    {menuOpen && viewMode !== 'live' && (
                        <div className="absolute right-4 top-4 bottom-4 w-64 bg-zinc-900/95 backdrop-blur border border-zinc-700 rounded-xl shadow-2xl z-50 flex flex-col overflow-hidden">
                            <div className="p-4 border-b border-zinc-700 flex justify-between items-center bg-zinc-900">
                                <span className="font-bold flex items-center gap-2"> <Settings size={18} /> Configuration </span>
                                <button onClick={() => setMenuOpen(false)} className="text-gray-400 hover:text-white">&times;</button>
                            </div>
                            <div className="px-4 pt-4">
                                <select value={viewMode} onChange={(e) => { setViewMode(e.target.value); if(e.target.value === 'live') setMenuOpen(false); }} className="w-full bg-zinc-800 border border-zinc-600 rounded p-2 text-sm font-bold text-white outline-none focus:border-blue-500">
                                    <option value="2d">Mapping Studio (2D)</option>
                                    <option value="3d">Simulation (3D)</option>
                                    <option value="live">ðŸ”´ Live Presentation</option>
                                </select>
                            </div>
                            <div className="flex border-b border-zinc-800 mt-4">
                                <button onClick={() => setMenuTab('config')} className={`flex-1 py-2 text-xs font-bold ${menuTab === 'config' ? 'text-blue-400 border-b-2 border-blue-400' : 'text-gray-500 hover:text-gray-300'}`}>Geometry</button>
                                <button onClick={() => setMenuTab('scenes')} className={`flex-1 py-2 text-xs font-bold ${menuTab === 'scenes' ? 'text-purple-400 border-b-2 border-purple-400' : 'text-gray-500 hover:text-gray-300'}`}>Scenes</button>
                            </div>

                            <div className="flex-1 overflow-y-auto p-4 space-y-6">
                                {menuTab === 'config' && (
                                    <>
                                        <button onClick={calibrate} className={`w-full p-2 rounded text-sm font-medium flex items-center justify-center gap-2 transition-all duration-300 ${calibrationSuccess ? 'bg-green-600 hover:bg-green-500 text-white scale-105 shadow-lg shadow-green-900/50' : 'bg-blue-600 hover:bg-blue-500 text-white'}`}> {calibrationSuccess ? <><CheckCircle size={16} className="animate-scale" /> Done!</> : <><Calculator size={16} /> Calibrate Pose</>} </button>
                                        <div className="flex gap-2">
                                            {viewMode === '3d' && (
                                                <button onClick={() => setShowGuides(p => !p)} className={`w-full p-2 rounded text-xs flex items-center justify-center gap-1 border transition-colors ${showGuides ? 'bg-blue-900/50 border-blue-500 text-blue-200' : 'bg-zinc-800 border-zinc-700 text-gray-300'}`}> <Grid3X3 size={14} /> Guides </button>
                                            )}
                                        </div>
                                        {viewMode === '2d' && (<div className="grid grid-cols-3 gap-2"><button onClick={() => setMoveMode(p => !p)} className={`p-2 rounded text-xs flex items-center justify-center gap-1 border transition-colors ${moveMode ? 'bg-orange-600 border-orange-400 text-white' : 'bg-zinc-800 border-zinc-700 text-gray-300'}`}> <Move size={14} /> Move </button><button onClick={() => setShowGuides(p => !p)} className={`p-2 rounded text-xs flex items-center justify-center gap-1 border transition-colors ${showGuides ? 'bg-blue-900/50 border-blue-500 text-blue-200' : 'bg-zinc-800 border-zinc-700 text-gray-300'}`}> <Grid3X3 size={14} /> Guide </button><button onClick={() => setShowTexture(p => !p)} className={`p-2 rounded text-xs flex items-center justify-center gap-1 border transition-colors ${showTexture ? 'bg-white text-black border-white font-bold' : 'bg-zinc-800 border-zinc-700 text-gray-300'}`}> <QrCode size={14} /> Tex </button></div>)}
                                        <div className="bg-zinc-800/50 p-3 rounded-lg border border-zinc-700"><div className="flex justify-between text-xs text-gray-400 mb-2"><span>Throw Ratio</span> <span className="text-white">{throwRatio}</span></div><input type="range" min="0.5" max="3.0" step="0.1" value={throwRatio} onChange={(e) => setThrowRatio(parseFloat(e.target.value))} className="w-full h-1 bg-gray-600 rounded-lg appearance-none cursor-pointer accent-blue-500" /></div>
                                        {activeWall && (<div className="space-y-3 bg-zinc-900 border border-zinc-700 p-3 rounded-lg"><div className="flex items-center gap-2 mb-2 pb-2 border-b border-zinc-800"><div className="w-3 h-3 rounded-full" style={{ backgroundColor: activeWall.color }}></div><input type="text" value={activeWall.name} onChange={(e) => setWalls(p => p.map(w => w.id === activeWall.id ? { ...w, name: e.target.value } : w))} className="bg-transparent border-none outline-none text-sm font-bold text-white w-full" />{activeWall.isCalibrationTarget && <span className="text-[10px] bg-lime-900 text-lime-300 px-1 rounded whitespace-nowrap">ANCHOR</span>}</div><div className="grid grid-cols-2 gap-2"><div> <label className="text-[10px] text-gray-500">Width</label> <input type="number" value={activeWall.width} onChange={(e) => setWalls(p => p.map(w => w.id === activeWall.id ? { ...w, width: parseFloat(e.target.value) } : w))} className="w-full bg-zinc-800 border border-zinc-700 rounded px-2 py-1 text-xs" /> </div><div> <label className="text-[10px] text-gray-500">Height</label> <input type="number" value={activeWall.height} onChange={(e) => setWalls(p => p.map(w => w.id === activeWall.id ? { ...w, height: parseFloat(e.target.value) } : w))} className="w-full bg-zinc-800 border border-zinc-700 rounded px-2 py-1 text-xs" /> </div></div>{!activeWall.isCalibrationTarget && (<div className="grid grid-cols-2 gap-2 mt-1"><div><label className="text-[10px] text-gray-500 flex items-center gap-1 mb-1"><Folder size={10}/> Group</label><select value={activeWall.folderId || ""} onChange={(e) => setWalls(p => p.map(w => w.id === activeWall.id ? { ...w, folderId: e.target.value ? parseInt(e.target.value) : null } : w))} className="w-full bg-zinc-800 border border-zinc-700 rounded px-2 py-1 text-xs text-white outline-none"><option value="">None</option>{folders.map(f => <option key={f.id} value={f.id}>{f.name}</option>)}</select></div><div><label className="text-[10px] text-gray-500 flex items-center gap-1 mb-1"><Palette size={10}/> Color</label><div className="flex items-center gap-2 bg-zinc-800 border border-zinc-700 rounded px-2 py-0.5"><input type="color" value={activeWall.color} onChange={(e) => setWalls(p => p.map(w => w.id === activeWall.id ? { ...w, color: e.target.value } : w))} className="w-4 h-4 p-0 border-none bg-transparent cursor-pointer" /><span className="text-xs text-gray-400 font-mono">{activeWall.color}</span></div></div></div>)}</div>)}
                                        <div className="space-y-2"><div className="flex justify-between items-center"><h3 className="text-xs font-bold text-gray-500">OBJECTS</h3><div className="flex gap-1"><button onClick={addFolder} className="text-xs bg-zinc-800 hover:bg-zinc-700 px-2 py-1 rounded flex items-center gap-1" title="New Group"> <FolderPlus size={12} /> </button><button onClick={() => { const newId = Math.max(...walls.map(w => w.id)) + 1; setWalls(p => [...p, { id: newId, name: `Obj ${newId}`, width: 1, height: 1, color: `hsl(${Math.random()*360},70%,60%)`, isCalibrationTarget: false, folderId: null, pos: {x:0,y:0,z:1}, rot: {x:0,y:0,z:0}, points: [{x:300,y:300},{x:400,y:300},{x:400,y:400},{x:300,y:400}] }]); }} className="text-xs bg-zinc-800 hover:bg-zinc-700 px-2 py-1 rounded flex items-center gap-1" title="New Object"> <Plus size={12} /> </button></div></div>{walls.filter(w => w.isCalibrationTarget).map(wall => (<div key={wall.id} onClick={() => setActiveWallId(wall.id)} className={`flex justify-between items-center p-2 rounded text-xs cursor-pointer border-l-2 ${wall.id === activeWallId ? 'bg-zinc-800 text-white border-lime-500' : 'text-gray-400 hover:bg-zinc-800/50 border-transparent'}`}><div className="flex items-center gap-2 font-bold text-lime-400"><Target size={12} /> {wall.name}</div></div>))}{folders.map(folder => (<FolderItem key={folder.id} folder={folder} walls={walls} activeWallId={activeWallId} setActiveWallId={setActiveWallId} setWalls={setWalls} setFolders={setFolders} />))}{walls.filter(w => !w.isCalibrationTarget && w.folderId === null).map(wall => (<div key={wall.id} onClick={() => setActiveWallId(wall.id)} className={`flex justify-between items-center p-2 rounded text-xs cursor-pointer ${wall.id === activeWallId ? 'bg-zinc-800 text-white border border-zinc-600' : 'text-gray-400 hover:bg-zinc-800/50'}`}><div className="flex items-center gap-2"><div className="w-2 h-2 rounded-full" style={{ backgroundColor: wall.color }}></div>{wall.name}</div><button onClick={(e) => {e.stopPropagation(); setWalls(p => p.filter(w => w.id !== wall.id))}} className="hover:text-red-400"><Trash2 size={12}/></button></div>))}</div>
                                        {/* STORAGE SECTION */}
                                        <div className="mt-4 pt-4 border-t border-zinc-700">
                                            <div className="flex justify-between items-center mb-2">
                                                <h3 className="text-xs font-bold text-gray-500 flex items-center gap-1"><Database size={12}/> STORAGE</h3>
                                                {storageUsage && <span className="text-[10px] text-zinc-500">{storageUsage.usage}MB / {storageUsage.quota}MB</span>}
                                            </div>
                                            <button onClick={resetData} className="w-full text-xs text-red-400 border border-red-900/50 hover:bg-red-900/20 py-1 rounded flex items-center justify-center gap-2 transition-colors">
                                                <HardDrive size={12}/> Reset All Data
                                            </button>
                                        </div>
                                    </>
                                )}

                                {/* --- SCENES TAB --- */}
                                {menuTab === 'scenes' && (
                                    <div className="space-y-4">
                                        <div className="flex gap-2 border-b border-zinc-800 pb-2 mb-2">
                                            <button onClick={() => setShowNodeEditor(p => !p)} className={`w-full p-2 rounded text-xs flex items-center justify-center gap-1 border transition-colors ${showNodeEditor ? 'bg-purple-900/50 border-purple-500 text-purple-200' : 'bg-zinc-800 border-zinc-700 text-gray-300'}`} title="Toggle Node Editor">
                                                {showNodeEditor ? <Eye size={14}/> : <EyeOff size={14}/>} {showNodeEditor ? 'Hide Graph' : 'Show Graph'}
                                            </button>
                                        </div>
                                        <div className="space-y-1">
                                            <div className="flex justify-between items-center mb-2">
                                                <h3 className="text-xs font-bold text-gray-400 uppercase">Cue List</h3>
                                                <button onClick={addScene} className="text-xs bg-purple-600 hover:bg-purple-500 px-2 py-1 rounded flex items-center gap-1 text-white ml-2"><Plus size={12}/> Scene</button>
                                            </div>
                                            {scenes.map((scene, sIdx) => (
                                                <div key={scene.id} className="mb-3">
                                                    <div className="px-2 py-1 text-xs font-bold text-gray-500 uppercase border-b border-zinc-800 mb-1 flex justify-between items-center">
                                                        <span className="flex items-center gap-2"><Film size={10}/> {scene.name}</span>
                                                        <button onClick={() => addCue(scene.id)} className="text-[9px] bg-zinc-800 hover:bg-zinc-700 px-1.5 py-0.5 rounded text-gray-300">+ Cue</button>
                                                    </div>
                                                    <div className="space-y-0 pl-1">
                                                        {scene.cues.map((cue, cIdx) => {
                                                            const isActive = activeSelection.type === 'cue' && activeSelection.sceneId === scene.id && activeSelection.cueId === cue.id;
                                                            const nextCue = scene.cues[cIdx + 1] || (scenes[sIdx+1]?.cues[0]);
                                                            return (
                                                                <div key={cue.id}>
                                                                    <div onClick={() => setActiveSelection({ type: 'cue', sceneId: scene.id, cueId: cue.id })} className={`flex items-center gap-2 p-2 rounded text-xs cursor-pointer transition-all ${isActive ? 'bg-purple-900/50 border-l-2 border-purple-400 text-white' : 'hover:bg-zinc-800 text-gray-400 border-l-2 border-transparent'}`}>
                                                                        {isActive ? <Play size={10} fill="currentColor"/> : <span className="w-2.5"/>}
                                                                        <span className="truncate">{cue.name}</span>
                                                                    </div>
                                                                    {nextCue && (
                                                                        <div className={`h-2 my-0.5 rounded-full mx-2 cursor-pointer hover:bg-purple-500/50 transition-colors group relative flex justify-center items-center ${activeSelection.type === 'transition' && activeSelection.nextCueId === nextCue.id ? 'bg-purple-500' : 'bg-zinc-800'}`} onClick={() => setActiveSelection({ type: 'transition', sceneId: scene.id, prevCueId: cue.id, nextCueId: nextCue.id })}>
                                                                            <div className="w-3 h-3 rounded-full bg-zinc-600 border border-zinc-900 group-hover:bg-white group-hover:scale-125 transition-transform flex items-center justify-center"><Link size={8} className="text-zinc-900"/></div>
                                                                        </div>
                                                                    )}
                                                                </div>
                                                            )
                                                        })}
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                )}
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>