<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Projection Tool v1</title>
    <script src="lib/babel.min.js"></script>
    <script src="lib/tailwind.js"></script>
    <script src="lib/react.min.js"></script>
    <script src="lib/react-dom.min.js"></script>

    <style>
        body, html { margin: 0; padding: 0; background-color: black; overflow: hidden; color: white; height: 100%; font-family: 'Inter', sans-serif; }
        #root { width: 100%; height: 100%; }
        .no-select { user-select: none; -webkit-user-select: none; }
        
        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { 
            -webkit-appearance: none; 
            margin: 0; 
        }
        
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #18181b; }
        ::-webkit-scrollbar-thumb { background: #3f3f46; border-radius: 3px; }

        .animate-scale { animation: scaleUp 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }
        @keyframes scaleUp { 0% { transform: scale(0.8); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }
        
        .projection-path { transition: fill 0.1s linear, stroke 0.1s linear; }

        /* Node Grid */
        .node-grid {
            background-image: radial-gradient(#666 1px, transparent 1px);
            background-size: 20px 20px;
        }

        /* YouTube Iframe pointer events fix for dragging */
        iframe { pointer-events: none; }

        @keyframes zebraBlink { 0% { opacity: 0.2; } 50% { opacity: 0.5; } 100% { opacity: 0.2; } }
        .zebra-pattern {
            animation: zebraBlink 3s ease-in-out infinite;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useRef, useCallback } = React;
        const { createRoot } = ReactDOM;

        // --- 1. INLINE ICON LIBRARY (Replaces lucide-react) ---
        const IconWrapper = ({ children, size = 24, className = "", ...props }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} {...props}>{children}</svg>
        );
        
        const Icons = {
            Settings: (p) => <IconWrapper {...p}><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.09a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></IconWrapper>,
            Calculator: (p) => <IconWrapper {...p}><rect width="16" height="20" x="4" y="2" rx="2"/><line x1="8" x2="16" y1="6" y2="6"/><line x1="16" x2="16" y1="14" y2="18"/><path d="M16 10h.01"/><path d="M12 10h.01"/><path d="M8 10h.01"/><path d="M12 14h.01"/><path d="M8 14h.01"/><path d="M12 18h.01"/><path d="M8 18h.01"/></IconWrapper>,
            Move3d: (p) => <IconWrapper {...p}><path d="M5 3v16h16"/><path d="m5 19 6-6"/><path d="m2 6 3-3 3 3"/><path d="m18 16 3 3-3 3"/></IconWrapper>,
            Eye: (p) => <IconWrapper {...p}><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/></IconWrapper>,
            EyeOff: (p) => <IconWrapper {...p}><path d="M9.88 9.88a3 3 0 1 0 4.24 4.24"/><path d="M10.73 5.08A10.43 10.43 0 0 1 12 5c7 0 10 7 10 7a13.16 13.16 0 0 1-1.67 2.68"/><path d="M6.61 6.61A13.526 13.526 0 0 0 2 12s3 7 10 7c.44 0 .87-.03 1.28-.09"/><line x1="2" x2="22" y1="2" y2="22"/></IconWrapper>,
            Plus: (p) => <IconWrapper {...p}><path d="M5 12h14"/><path d="M12 5v14"/></IconWrapper>,
            Trash2: (p) => <IconWrapper {...p}><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></IconWrapper>,
            Target: (p) => <IconWrapper {...p}><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/></IconWrapper>,
            Rotate3D: (p) => <IconWrapper {...p}><path d="M16.466 7.5C15.643 4.237 13.952 2 12 2 9.239 2 7 6.477 7 12s2.239 10 5 10c.342 0 .677-.069 1-.2"/><path d="m15.194 13.707 3.814 1.86-1.86 3.814"/><path d="M19 15.57c-1.804.885-4.274 1.43-7 1.43-5.523 0-10-2.239-10-5s4.477-5 10-5c4.838 0 8.873 1.718 9.8 4"/></IconWrapper>,
            Ruler: (p) => <IconWrapper {...p}><path d="M21.3 15.3a2.4 2.4 0 0 1 0 3.4l-2.6 2.6a2.4 2.4 0 0 1-3.4 0L2.7 8.7a2.41 2.41 0 0 1 0-3.4l2.6-2.6a2.41 2.41 0 0 1 3.4 0Z"/><path d="m14.5 12.5 2-2"/><path d="m11.5 9.5 2-2"/><path d="m8.5 6.5 2-2"/><path d="m17.5 15.5 2-2"/></IconWrapper>,
            Box: (p) => <IconWrapper {...p}><path d="M21 8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16Z"/><path d="m3.3 7 8.7 5 8.7-5"/><path d="M12 22V12"/></IconWrapper>,
            Move: (p) => <IconWrapper {...p}><polyline points="5 9 2 12 5 15"/><polyline points="9 5 12 2 15 5"/><polyline points="19 9 22 12 19 15"/><polyline points="15 19 12 22 9 19"/><line x1="2" x2="22" y1="12" y2="12"/><line x1="12" x2="12" y1="2" y2="22"/></IconWrapper>,
            Grid3X3: (p) => <IconWrapper {...p}><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M3 9h18"/><path d="M3 15h18"/><path d="M9 3v18"/><path d="M15 3v18"/></IconWrapper>,
            QrCode: (p) => <IconWrapper {...p}><rect width="5" height="5" x="3" y="3" rx="1"/><rect width="5" height="5" x="16" y="3" rx="1"/><rect width="5" height="5" x="3" y="16" rx="1"/><path d="M21 16h-3a2 2 0 0 0-2 2v3"/><path d="M21 21v.01"/><path d="M12 7v3a2 2 0 0 1-2 2H7"/><path d="M3 12h.01"/><path d="M12 3h.01"/><path d="M12 16v.01"/><path d="M16 12h1"/><path d="M21 12v.01"/><path d="M12 21v-1"/></IconWrapper>,
            Folder: (p) => <IconWrapper {...p}><path d="M4 20h16a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.93a2 2 0 0 1-1.66-.9l-.82-1.2A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13c0 1.1.9 2 2 2Z"/></IconWrapper>,
            ChevronRight: (p) => <IconWrapper {...p}><path d="m9 18 6-6-6-6"/></IconWrapper>,
            ChevronDown: (p) => <IconWrapper {...p}><path d="m6 9 6 6 6-6"/></IconWrapper>,
            ChevronUp: (p) => <IconWrapper {...p}><path d="m18 15-6-6-6 6"/></IconWrapper>,
            Palette: (p) => <IconWrapper {...p}><circle cx="13.5" cy="6.5" r=".5"/><circle cx="17.5" cy="10.5" r=".5"/><circle cx="8.5" cy="7.5" r=".5"/><circle cx="6.5" cy="12.5" r=".5"/><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z"/></IconWrapper>,
            CheckCircle: (p) => <IconWrapper {...p}><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></IconWrapper>,
            Axis3d: (p) => <IconWrapper {...p}><path d="M4 4v16h16"/><path d="m4 20 7-7"/></IconWrapper>,
            MousePointer2: (p) => <IconWrapper {...p}><path d="m12 6 4 6-2.29 2.29 4.29 4.29-1.41 1.41-4.29-4.29L10 18Z"/></IconWrapper>,
            Clapperboard: (p) => <IconWrapper {...p}><path d="M20.2 6 3 11l-.9-2.4c-.5-1.1.2-2.4 1.3-2.9l13.2-4.8c1.1-.5 2.4.2 2.9 1.3l.7 1.8Z"/><path d="m6.2 5.3 3.1 3.9"/><path d="m12.4 3.4 3.1 4"/><path d="M3 11h18v8a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2Z"/></IconWrapper>,
            Image: (p) => <IconWrapper {...p}><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><circle cx="9" cy="9" r="2"/><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"/></IconWrapper>,
            Upload: (p) => <IconWrapper {...p}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" x2="12" y1="3" y2="15"/></IconWrapper>,
            Play: (p) => <IconWrapper {...p}><polygon points="5 3 19 12 5 21 5 3"/></IconWrapper>,
            SkipBack: (p) => <IconWrapper {...p}><polygon points="19 20 9 12 19 4 19 20"/><line x1="5" x2="5" y1="19" y2="5"/></IconWrapper>,
            SkipForward: (p) => <IconWrapper {...p}><polygon points="5 4 15 12 5 20 5 4"/><line x1="19" x2="19" y1="5" y2="19"/></IconWrapper>,
            LayoutTemplate: (p) => <IconWrapper {...p}><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M3 9h18"/><path d="M9 21V9"/></IconWrapper>,
            MonitorOff: (p) => <IconWrapper {...p}><path d="M17 17H4a2 2 0 0 1-2-2V5c0-1.5 1-2 1-3"/><path d="M22 15V5a2 2 0 0 0-2-2H9"/><path d="M8 21h8"/><path d="M12 17v4"/><line x1="2" x2="22" y1="2" y2="22"/></IconWrapper>,
            Film: (p) => <IconWrapper {...p}><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M7 3v18"/><path d="M3 7.5h4"/><path d="M3 12h18"/><path d="M3 16.5h4"/><path d="M17 3v18"/><path d="M17 7.5h4"/><path d="M17 16.5h4"/></IconWrapper>,
            Timer: (p) => <IconWrapper {...p}><line x1="10" x2="14" y1="2" y2="2"/><line x1="12" x2="15" y1="14" y2="11"/><circle cx="12" cy="14" r="8"/></IconWrapper>,
            Activity: (p) => <IconWrapper {...p}><path d="M22 12h-4l-3 9L9 3l-3 9H2"/></IconWrapper>,
            Layers: (p) => <IconWrapper {...p}><polygon points="12 2 2 7 12 12 22 7 12 2"/><polyline points="2 17 12 22 22 17"/><polyline points="2 12 12 17 22 12"/></IconWrapper>,
            Workflow: (p) => <IconWrapper {...p}><rect width="8" height="8" x="3" y="3" rx="2"/><path d="M7 11v4a2 2 0 0 0 2 2h4"/><rect width="8" height="8" x="13" y="13" rx="2"/></IconWrapper>,
            Link: (p) => <IconWrapper {...p}><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></IconWrapper>,
            X: (p) => <IconWrapper {...p}><path d="M18 6 6 18"/><path d="m6 6 18 18"/></IconWrapper>,
            Cable: (p) => <IconWrapper {...p}><path d="M17 21v-2a2 2 0 0 1 2-2h2"/><path d="M21 17v2a2 2 0 0 1-2 2h-2"/><path d="M3 5v2a2 2 0 0 1-2 2H0"/><path d="M7 5v2a2 2 0 0 1-2 2H4"/><path d="M3 3v2"/><path d="M7 3v2"/><path d="M10 2v2a2 2 0 0 1-2 2h-2"/><path d="M17 2v2a2 2 0 0 1-2 2h-2"/><path d="M21 2v2a2 2 0 0 1-2 2h-2"/><path d="M12 22v-2"/><path d="M12 2v2"/></IconWrapper>,
            Maximize: (p) => <IconWrapper {...p}><path d="M8 3H5a2 2 0 0 0-2 2v3"/><path d="M21 8V5a2 2 0 0 0-2-2h-3"/><path d="M3 16v3a2 2 0 0 0 2 2h3"/><path d="M16 21h3a2 2 0 0 0 2-2v-3"/></IconWrapper>,
            AlertTriangle: (p) => <IconWrapper {...p}><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><line x1="12" x2="12" y1="9" y2="13"/><line x1="12" x2="12.01" y1="17" y2="17"/></IconWrapper>,
            HardDrive: (p) => <IconWrapper {...p}><line x1="22" x2="22" y1="12" y2="12"/><path d="M2 12h20"/><path d="M5.45 5.11 2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z"/><line x1="6" x2="6.01" y1="16" y2="16"/><line x1="10" x2="10.01" y1="16" y2="16"/></IconWrapper>,
            Database: (p) => <IconWrapper {...p}><ellipse cx="12" cy="5" rx="9" ry="3"/><path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"/><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"/></IconWrapper>,
            Video: (p) => <IconWrapper {...p}><path d="m22 8-6 4 6 4V8Z"/><rect width="14" height="12" x="2" y="6" rx="2" ry="2"/></IconWrapper>,
            Blend: (p) => <IconWrapper {...p}><circle cx="9" cy="9" r="7"/><circle cx="15" cy="15" r="7"/></IconWrapper>
        };
        
        const { Settings, Calculator, Move3d, Eye, EyeOff, Plus, Trash2, Target, Rotate3D, Ruler, Box: BoxIcon, Move, Grid3X3, QrCode, Folder, ChevronRight, ChevronDown, ChevronUp, Palette, CheckCircle, Axis3d, MousePointer2, Clapperboard, Image: ImageIcon, Upload, Play, SkipBack, SkipForward, LayoutTemplate, MonitorOff, Film, Timer, Activity, Layers, Workflow, Link, X, Cable, Maximize, AlertTriangle, HardDrive, Database, Video, Blend } = Icons;

        // --- ICONS & HELPERS ---
        const FolderPlus = ({size}) => ( <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 10v6M9 13h6"/><path d="M20 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L9.6 3.9A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2Z"/></svg> );

        // Helper to render a handle circle for nodes
        const HandleCircle = ({ type, title, top, active, onClick }) => {
            let colorClasses = '';
            if (type === 'output') {
                colorClasses = '-right-3.5 bg-gray-600 border-gray-300 hover:bg-blue-500 hover:border-white';
            } else if (type === 'base') {
                colorClasses = '-left-3.5 bg-red-900 border-red-500 hover:bg-red-600';
            } else if (type === 'blend') {
                colorClasses = '-left-3.5 bg-green-900 border-green-500 hover:bg-green-600';
            } else {
                // Default Input
                colorClasses = '-left-3.5 bg-lime-900 border-lime-500 hover:bg-lime-600';
            }

            return (
                <div 
                    className={`absolute w-7 h-7 rounded-full border-2 cursor-pointer z-50 transition-all duration-200 flex items-center justify-center ${colorClasses} ${active ? 'bg-white border-blue-400 scale-125 shadow-[0_0_10px_rgba(59,130,246,0.8)]' : ''}`}
                    style={{ top: `${top}px` }}
                    title={title}
                    data-handle={type}
                    onClick={onClick} 
                >
                    {active && <div className="w-3 h-3 rounded-full bg-blue-500"></div>}
                </div>
            );
        };

        // --- PERSISTENCE ENGINE (Server API) ---
        const DB_NAME = 'ProjectionToolDB';
        const DB_VERSION = 1;

        class PersistenceManager {
            constructor() {
                this.db = null;
                this.ready = this.init();
            }

            init() {
                // No local init needed for server DB
                return Promise.resolve();
            }

            async saveAsset(file) {
                const assetId = crypto.randomUUID();
                await fetch('/api/asset/' + assetId, {
                    method: 'POST',
                    headers: {
                        'Content-Type': file.type,
                        'X-Asset-Name': file.name
                    },
                    body: file
                });
                return assetId;
            }

            async getAsset(assetId) {
                const res = await fetch('/api/asset/' + assetId);
                if (!res.ok) return null;
                return await res.blob();
            }

            async getAllAssets() {
                const res = await fetch('/api/assets');
                if (!res.ok) return [];
                const list = await res.json();
                // Map to format expected by UI
                return list.map(item => ({
                    id: item.id,
                    url: '/api/asset/' + item.id,
                    type: item.mime_type.startsWith('video') ? 'video' : 'image',
                    file: { name: item.name } // Mock file object for UI display
                }));
            }

            async deleteAsset(id) {
                await fetch('/api/asset/' + id, { method: 'DELETE' });
            }

            async saveState(key, data) {
                await fetch('/api/kv/' + key, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
            }

            async loadState(key) {
                const res = await fetch('/api/kv/' + key);
                if (!res.ok) return null;
                return await res.json();
            }

            async clearAll() {
                // Not implemented for server safety, or implement a specific endpoint
                alert("Reset not fully supported in server mode yet.");
            }

            async getUsage() {
                return { usage: "Server", quota: "Disk" };
            }
        }

        const db = new PersistenceManager();

        // --- MATH ENGINE ---
        const solveHomography = (src, dst) => {
            let a = [], b = [];
            for (let i = 0; i < 4; i++) {
                let x = src[i].x, y = src[i].y, u = dst[i].x, v = dst[i].y;
                a.push([x, y, 1, 0, 0, 0, -x*u, -y*u]);
                a.push([0, 0, 0, x, y, 1, -x*v, -y*v]);
                b.push(u); b.push(v);
            }
            const n = 8;
            for (let i = 0; i < n; i++) {
                let maxEl = Math.abs(a[i][i]), maxRow = i;
                for (let k = i + 1; k < n; k++) if (Math.abs(a[k][i]) > maxEl) { maxEl = Math.abs(a[k][i]); maxRow = k; }
                for (let k = i; k < n; k++) { let tmp = a[maxRow][k]; a[maxRow][k] = a[i][k]; a[i][k] = tmp; }
                let tmp = b[maxRow]; b[maxRow] = b[i]; b[i] = tmp;
                for (let k = i + 1; k < n; k++) {
                    let c = -a[k][i] / a[i][i];
                    for (let j = i; j < n; j++) { if (i === j) a[k][j] = 0; else a[k][j] += c * a[i][j]; }
                    b[k] += c * b[i];
                }
            }
            let x = new Array(n).fill(0);
            for (let i = n - 1; i > -1; i--) {
                let sum = 0;
                for (let j = i + 1; j < n; j++) sum += a[i][j] * x[j];
                x[i] = (b[i] - sum) / a[i][i];
            }
            return [[x[0], x[1], x[2]], [x[3], x[4], x[5]], [x[6], x[7], 1]];
        };

        const applyHomography = (H, x, y) => {
            const w = H[2][0] * x + H[2][1] * y + H[2][2];
            const tx = (H[0][0] * x + H[0][1] * y + H[0][2]) / w;
            const ty = (H[1][0] * x + H[1][1] * y + H[1][2]) / w;
            return { x: tx, y: ty };
        };

        const getCssMatrix = (dstPoints, width, height) => {
             const src = [{x:0, y:0}, {x:width, y:0}, {x:width, y:height}, {x:0, y:height}];
             const H = solveHomography(src, dstPoints);
             const m = H;
             return `matrix3d(${m[0][0]}, ${m[1][0]}, 0, ${m[2][0]},${m[0][1]}, ${m[1][1]}, 0, ${m[2][1]},0, 0, 1, 0,${m[0][2]}, ${m[1][2]}, 0, ${m[2][2]})`;
        };

        const getDistance = (p1, p2) => Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));

        // --- COMPONENTS ---

        const PointHandle = ({ x, y, index, color, isSelected, onDrag, isMoveMode }) => {
            const [isDragging, setIsDragging] = useState(false);
            useEffect(() => {
                if (isDragging) {
                    const handleMouseMove = (e) => onDrag(index, e.clientX, e.clientY);
                    const handleMouseUp = () => setIsDragging(false);
                    window.addEventListener('mousemove', handleMouseMove);
                    window.addEventListener('mouseup', handleMouseUp);
                    return () => window.removeEventListener('mousemove', handleMouseMove);
                }
            }, [isDragging]);
            return (
                <g transform={`translate(${x}, ${y})`} style={{ cursor: isMoveMode ? 'move' : (isSelected ? 'move' : 'default') }} onMouseDown={() => isSelected && setIsDragging(true)}>
                    <circle r="30" fill="transparent" />
                    <circle r="12" fill={isMoveMode ? "#fb923c" : color} fillOpacity={isSelected ? 0.3 : 0.1} />
                    <circle r={isSelected ? 6 : 4} fill={isMoveMode ? "#fb923c" : color} stroke="black" strokeWidth="1" />
                    {isSelected && <text x="15" y="5" fill="white" fontSize="10" className="no-select font-mono pointer-events-none">P{index + 1}</text>}
                </g>
            );
        };

        const WarpedTextureGrid = ({ wallPoints }) => {
            const grid = useMemo(() => {
                const src = [{x:0, y:0}, {x:1, y:0}, {x:1, y:1}, {x:0, y:1}];
                const H = solveHomography(src, wallPoints);
                const cells = [];
                const gridSize = 10; 
                for(let y=0; y<gridSize; y++) {
                    for(let x=0; x<gridSize; x++) {
                        const u = x / gridSize; const v = y / gridSize;
                        const u2 = (x+1) / gridSize; const v2 = (y+1) / gridSize;
                        const p1 = applyHomography(H, u, v); 
                        const p2 = applyHomography(H, u2, v); 
                        const p3 = applyHomography(H, u2, v2); 
                        const p4 = applyHomography(H, u, v2);
                        const isWhite = (x + y) % 2 === 0;
                        cells.push(<path key={`${x}-${y}`} d={`M ${p1.x} ${p1.y} L ${p2.x} ${p2.y} L ${p3.x} ${p3.y} L ${p4.x} ${p4.y} Z`} fill={isWhite ? "white" : "black"} stroke="none" />);
                    }
                }
                return cells;
            }, [wallPoints]);
            return <g opacity="0.6">{grid}</g>;
        };

        const AssetBrowser = ({ isOpen, onClose, onSelect, initialTab = 'image' }) => {
            const [activeTab, setActiveTab] = useState(initialTab);
            const [assets, setAssets] = useState([]);
            const fileInputRef = useRef(null);

            useEffect(() => {
                if (isOpen) {
                    setActiveTab(initialTab);
                    loadAssets();
                }
            }, [isOpen, initialTab]);

            const loadAssets = async () => {
                const all = await db.getAllAssets();
                setAssets(all);
            };

            const handleUpload = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                try {
                    await db.saveAsset(file);
                    await loadAssets();
                } catch (err) {
                    console.error(err);
                }
            };

            const handleDelete = async (e, id) => {
                e.stopPropagation();
                if(confirm('Delete this asset?')) {
                    await db.deleteAsset(id);
                    await loadAssets();
                }
            };

            const filteredAssets = assets.filter(a => a.type === activeTab);

            if (!isOpen) return null;

            return (
                <div className="fixed inset-0 z-[200] bg-black/80 backdrop-blur-sm flex items-center justify-center p-8">
                    <div className="bg-zinc-900 border border-zinc-700 rounded-xl w-full max-w-4xl h-[80vh] flex flex-col shadow-2xl overflow-hidden">
                        <div className="p-4 border-b border-zinc-700 flex justify-between items-center bg-zinc-950">
                            <h2 className="text-lg font-bold text-white flex items-center gap-2"><Folder size={20} className="text-blue-400"/> Asset Library</h2>
                            <button onClick={onClose} className="text-gray-400 hover:text-white"><X size={24}/></button>
                        </div>
                        <div className="flex border-b border-zinc-800 bg-zinc-900">
                            <button onClick={() => setActiveTab('image')} className={`flex-1 py-3 text-sm font-bold flex items-center justify-center gap-2 ${activeTab === 'image' ? 'text-blue-400 border-b-2 border-blue-400 bg-zinc-800/50' : 'text-gray-500 hover:text-gray-300'}`}>
                                <ImageIcon size={16}/> Images
                            </button>
                            <button onClick={() => setActiveTab('video')} className={`flex-1 py-3 text-sm font-bold flex items-center justify-center gap-2 ${activeTab === 'video' ? 'text-pink-400 border-b-2 border-pink-400 bg-zinc-800/50' : 'text-gray-500 hover:text-gray-300'}`}>
                                <Video size={16}/> Videos
                            </button>
                        </div>
                        <div className="flex-1 overflow-y-auto p-4 bg-zinc-900/50">
                            <div className="grid grid-cols-4 md:grid-cols-5 gap-4">
                                <div onClick={() => fileInputRef.current.click()} className="aspect-square border-2 border-dashed border-zinc-700 rounded-lg flex flex-col items-center justify-center cursor-pointer hover:border-blue-500 hover:bg-zinc-800 transition-colors group">
                                    <div className="w-12 h-12 rounded-full bg-zinc-800 flex items-center justify-center mb-2 group-hover:bg-blue-600 transition-colors">
                                        <Plus size={24} className="text-gray-400 group-hover:text-white"/>
                                    </div>
                                    <span className="text-xs font-bold text-gray-500 group-hover:text-gray-300">Upload New</span>
                                    <input type="file" ref={fileInputRef} className="hidden" accept={activeTab === 'video' ? "video/*" : "image/*"} onChange={handleUpload} />
                                </div>
                                {filteredAssets.map(asset => (
                                    <div key={asset.id} onClick={() => onSelect(asset)} className="aspect-square bg-black border border-zinc-700 rounded-lg overflow-hidden relative group cursor-pointer hover:ring-2 hover:ring-blue-500">
                                        {asset.type === 'video' ? <video src={asset.url} className="w-full h-full object-cover pointer-events-none" /> : <img src={asset.url} className="w-full h-full object-cover" />}
                                        <div className="absolute inset-0 bg-black/0 group-hover:bg-black/40 transition-colors flex items-center justify-center opacity-0 group-hover:opacity-100">
                                            <div className="absolute top-2 right-2">
                                                <button onClick={(e) => handleDelete(e, asset.id)} className="p-1.5 bg-red-600 rounded-md text-white hover:bg-red-500 shadow-lg" title="Delete Asset"><Trash2 size={14}/></button>
                                            </div>
                                            <span className="bg-blue-600 text-white text-xs font-bold px-3 py-1 rounded-full shadow-lg transform translate-y-4 group-hover:translate-y-0 transition-transform">Select</span>
                                        </div>
                                        <div className="absolute bottom-0 left-0 right-0 bg-black/60 backdrop-blur px-2 py-1">
                                            <p className="text-[10px] text-gray-300 truncate">{asset.file.name}</p>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // --- BLENDER-STYLE NOISE LIBRARY ---

        const ProceduralLib = {
            // 1. Math Helpers
            lerp: (a, b, t) => a + t * (b - a),
            smoothstep: (t) => t * t * (3 - 2 * t),
            fade: (t) => t * t * t * (t * (t * 6 - 15) + 10),
            
            // Gradient vector table for Perlin noise
            grad3: [
                [1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
                [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
                [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]
            ],
            
            // Permutation table (shuffled 0-255)
            p: new Uint8Array([151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,151]), // Repeated once in init

            init() {
                this.perm = new Uint8Array(512);
                for(let i=0; i<512; i++) this.perm[i] = this.p[i & 255];
            },

            dot(g, x, y) { return g[0]*x + g[1]*y; },

            // 2. Gradient Noise (Better Perlin)
            // Returns -1.0 to 1.0
            noise2D(x, y) {
                if(!this.perm) this.init();
                
                let X = Math.floor(x) & 255;
                let Y = Math.floor(y) & 255;
                
                x -= Math.floor(x);
                y -= Math.floor(y);
                
                let u = this.fade(x);
                let v = this.fade(y);
                
                let A = this.perm[X]+Y, AA = this.perm[A], AB = this.perm[A+1];
                let B = this.perm[X+1]+Y, BA = this.perm[B], BB = this.perm[B+1];
                
                return this.lerp(
                    this.lerp(this.dot(this.grad3[AA % 12], x, y), this.dot(this.grad3[BA % 12], x-1, y), u),
                    this.lerp(this.dot(this.grad3[AB % 12], x, y-1), this.dot(this.grad3[BB % 12], x-1, y-1), u),
                    v
                );
            },

            // 3. Cellular / Voronoi Noise (Blender style)
            // Returns { distance, id }
            // type: 'euclidean', 'manhattan', 'chebychev'
            voronoi(x, y, type = 'euclidean') {
                const xi = Math.floor(x);
                const yi = Math.floor(y);
                
                let minDist = 100;
                let cellId = 0;

                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        const neighborX = xi + i;
                        const neighborY = yi + j;
                        
                        // Hash for random point offset
                        // Simple sin-based pseudo random for deterministic position
                        const n = (neighborX & 255) * 31 + (neighborY & 255) * 13;
                        let t = (n << 13) ^ n;
                        const randVal = (1.0 - ((t * (t * t * 15731 + 789221) + 1376312589) & 0x7fffffff) / 1073741824.0);
                        const randVal2 = (1.0 - (((t+1) * ((t+1) * (t+1) * 15731 + 789221) + 1376312589) & 0x7fffffff) / 1073741824.0);

                        const pointX = neighborX + 0.5 + 0.5 * Math.sin(randVal * 6.28);
                        const pointY = neighborY + 0.5 + 0.5 * Math.cos(randVal2 * 6.28);

                        let dist;
                        const dx = x - pointX;
                        const dy = y - pointY;

                        if (type === 'manhattan') dist = Math.abs(dx) + Math.abs(dy);
                        else if (type === 'chebychev') dist = Math.max(Math.abs(dx), Math.abs(dy));
                        else dist = Math.sqrt(dx*dx + dy*dy); // Euclidean

                        if (dist < minDist) {
                            minDist = dist;
                            cellId = randVal;
                        }
                    }
                }
                return { distance: minDist, id: cellId };
            },

            // 4. Fractal Brownian Motion (The "Detail" slider in Blender)
            // Handles Standard, Ridge (Lightning), and Turbulence
            fbm(x, y, octaves, lacunarity = 2, gain = 0.5, type = 'standard') {
                let total = 0;
                let amplitude = 0.5;
                let frequency = 1;
                let maxValue = 0;

                for (let i = 0; i < octaves; i++) {
                    let n = this.noise2D(x * frequency, y * frequency);
                    
                    if (type === 'turbulence') {
                        n = Math.abs(n); // Billowy look
                    } else if (type === 'ridge') {
                        n = 1.0 - Math.abs(n);
                        n = n * n; // Sharpen peaks
                    } else {
                        n = (n + 1) / 2; // Normalize standard to 0-1
                    }

                    total += n * amplitude;
                    maxValue += amplitude;
                    amplitude *= gain;
                    frequency *= lacunarity;
                }
                
                // Normalize back to 0-1
                return total / maxValue;
            },

            // 5. Domain Warping (The "Distortion" effect in Blender)
            warp(x, y, amount) {
                const qx = this.fbm(x, y, 2);
                const qy = this.fbm(x + 5.2, y + 1.3, 2);
                return { x: x + amount * qx, y: y + amount * qy };
            }
        };

        const NoiseCanvas = ({ type = 'perlin', scale = 5, detail = 4, time = 0, distortion = 0 }) => {
            const canvasRef = useRef(null);

            useEffect(() => {
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                const { width, height } = canvas;
                // Reuse buffer if possible for performance
                const imgData = ctx.createImageData(width, height);
                const data = imgData.data;

                // Pre-calculate scaling factors
                const aspect = width / height;
                const noiseScale = scale / 10; 

                for (let i = 0; i < data.length; i += 4) {
                    // Pixel coordinates normalized
                    let u = (i / 4) % width / width;
                    let v = Math.floor((i / 4) / width) / height;
                    
                    // Aspect ratio correction
                    u *= aspect;

                    // Coordinate Space with Time
                    let x = u * scale;
                    let y = v * scale;
                    
                    // Add Time z-scroll
                    const t = time * 0.1;
                    
                    // Domain Warping (Blender Distortion)
                    if (distortion > 0) {
                        const warped = ProceduralLib.warp(x, y + t, distortion);
                        x = warped.x;
                        y = warped.y;
                    }

                    let val = 0;

                    if (type === 'perlin') {
                        // Standard Gradient Noise
                        val = ProceduralLib.noise2D(x, y + t);
                        val = (val + 1) / 2; // -1..1 to 0..1
                    } 
                    else if (type === 'fbm') {
                        // Fractal Noise (Clouds)
                        val = ProceduralLib.fbm(x, y + t, Math.floor(detail));
                    } 
                    else if (type === 'ridge') {
                        // Ridge Multifractal (Lightning/Electricity)
                        val = ProceduralLib.fbm(x, y + t, Math.floor(detail), 2, 0.5, 'ridge');
                    }
                    else if (type === 'worley') {
                        // Cellular (Bubbles/Stone)
                        const vData = ProceduralLib.voronoi(x, y + t, 'euclidean');
                        val = vData.distance; 
                        val = Math.min(1, val); // Clamp
                        val = 1.0 - val; // Invert for "Bubble" look
                    }
                    else if (type === 'cells') {
                        // Cellular ID (Stained Glass look)
                        const vData = ProceduralLib.voronoi(x, y + t, 'euclidean');
                        val = vData.id; 
                    }
                    
                    // Contrast/Clamp curve
                    val = Math.max(0, Math.min(1, val));

                    const color = val * 255;
                    data[i] = color;     // R
                    data[i+1] = color;   // G
                    data[i+2] = color;   // B
                    data[i+3] = 255;     // Alpha
                }
                ctx.putImageData(imgData, 0, 0);
            }, [type, scale, detail, time, distortion]);

            return <canvas ref={canvasRef} width="512" height="512" style={{width: '100%', height: '100%', objectFit: 'cover'}} />;
        };

        // --- RENDER ENGINE V22 ---

        const RenderNode = ({ nodeId, nodes, connections, resolution, wallColor, isLive, isTransitioning }) => {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return null;

            const getStyle = () => {
                const fit = node.data.fit || 'cover';
                const scale = node.data.scale || 1;
                const rotate = node.data.rotate || 0;
                const alignX = node.data.alignX ?? 50;
                const alignY = node.data.alignY ?? 50;
                
                const isStretch = fit === 'fill';
                const originX = isStretch ? 50 : alignX;
                const originY = isStretch ? 50 : alignY;

                return {
                    width: '100%', 
                    height: '100%', 
                    objectFit: fit,
                    objectPosition: isStretch ? 'center' : `${alignX}% ${alignY}%`,
                    transform: `scale(${scale}) rotate(${rotate}deg)`,
                    transformOrigin: `${originX}% ${originY}%`,
                };
            };

            if (node.type === 'color') {
                return <div style={{width: '100%', height: '100%', backgroundColor: node.data.value || 'black'}}></div>;
            }

            if (node.type === 'image' || node.type === 'video') {
                const style = getStyle();
                return (
                    <div style={{width: '100%', height: '100%', position: 'relative', backgroundColor: 'black'}}>
                        {wallColor && !isLive && !isTransitioning && (
                            <div className="zebra-pattern absolute inset-0" style={{
                                backgroundImage: `repeating-linear-gradient(45deg, ${wallColor} 0, ${wallColor} 10px, transparent 10px, transparent 20px)`
                            }}></div>
                        )}
                        {node.type === 'image' && node.data.value && <img src={node.data.value} style={style} />}
                        {node.type === 'video' && node.data.value && <video src={node.data.value} style={style} autoPlay loop muted playsInline />}
                    </div>
                );
            }

            if (node.type === 'noise') {
                return <NoiseCanvas type={node.data.noiseType} scale={node.data.scale} detail={node.data.detail} time={node.data.time} distortion={node.data.distortion} />;
            }

            if (node.type === 'mix') {
                const baseConn = connections.find(c => c.to === nodeId && c.toHandle === 'base');
                const blendConn = connections.find(c => c.to === nodeId && c.toHandle === 'blend');

                return (
                    <div style={{position: 'relative', width: '100%', height: '100%'}}>
                        <div style={{position: 'absolute', inset: 0}}>
                            {baseConn && <RenderNode nodeId={baseConn.from} nodes={nodes} connections={connections} resolution={resolution} wallColor={wallColor} isLive={isLive} isTransitioning={isTransitioning} />}
                        </div>
                        {blendConn && (
                            <div style={{
                                position: 'absolute', 
                                inset: 0, 
                                mixBlendMode: node.data.blendMode || 'normal'
                            }}>
                                 <RenderNode nodeId={blendConn.from} nodes={nodes} connections={connections} resolution={resolution} wallColor={wallColor} isLive={isLive} isTransitioning={isTransitioning} />
                            </div>
                        )}
                    </div>
                );
            }

            return null;
        };

        const getInterpolatedNode = (prevNode, currNode, mix) => {
            const newData = { ...currNode.data };
            const keys = ['scale', 'alignX', 'alignY', 'rotate', 'opacity', 'distortion', 'detail', 'time', 'animSpeed'];
            keys.forEach(key => {
                let def = 0;
                if (key === 'scale') def = 1;
                if (key === 'alignX' || key === 'alignY') def = 50;
                if (key === 'detail') def = 4;
                if (key === 'animSpeed') def = 0.1;
                const v1 = prevNode.data[key] ?? def;
                const v2 = currNode.data[key] ?? def;
                if (typeof v1 === 'number' && typeof v2 === 'number') {
                    newData[key] = v1 + (v2 - v1) * mix;
                }
            });
            return { ...currNode, data: newData };
        };

        const TransitioningProjectedContent = ({ prevCueState, currentCueState, mix, walls, isLive }) => {
            const getRootNodeId = (state, wallId) => {
                if (!state || !state.nodes) return null;
                const out = state.nodes.find(n => n.type === 'output' && n.data.wallId === wallId);
                if (!out) return null;
                const conn = state.connections?.find(c => c.to === out.id);
                return conn ? conn.from : null;
            };

            const isTransitioning = mix < 1 && !!prevCueState;

            return (
                <div className="absolute inset-0 overflow-hidden pointer-events-none">
                    {walls.map(wall => {
                        const prevRootId = getRootNodeId(prevCueState, wall.id);
                        const currRootId = getRootNodeId(currentCueState, wall.id);
                        
                        const p = wall.points;
                        const width = Math.max(getDistance(p[0], p[1]), getDistance(p[2], p[3]));
                        const height = Math.max(getDistance(p[1], p[2]), getDistance(p[3], p[0]));
                        const cssM = getCssMatrix(wall.points, width, height);

                        const isSameNode = prevRootId && currRootId && prevRootId === currRootId;
                        
                        let currentNodeToRender = null;
                        if (currRootId) {
                            let nodesToUse = currentCueState.nodes;
                            if (isTransitioning && isSameNode) {
                                nodesToUse = currentCueState.nodes.map(n => {
                                    const prev = prevCueState.nodes?.find(pn => pn.id === n.id);
                                    return prev ? getInterpolatedNode(prev, n, mix) : n;
                                });
                            }
                            currentNodeToRender = (
                                <RenderNode 
                                    nodeId={currRootId} 
                                    nodes={nodesToUse} 
                                    connections={currentCueState.connections} 
                                    resolution={height} 
                                    wallColor={wall.color} 
                                    isLive={isLive} 
                                    isTransitioning={isTransitioning} 
                                />
                            );
                        }

                        const currentLayerOpacity = (isTransitioning && !isSameNode) ? mix : 1;

                        return (
                            <div key={wall.id} className="absolute left-0 top-0 origin-top-left will-change-transform" style={{ width: `${width}px`, height: `${height}px`, transform: cssM, overflow: 'hidden' }}>
                                {isTransitioning && !isSameNode && prevRootId && (
                                    <div key={prevRootId} style={{ opacity: 1 - mix, position: 'absolute', inset: 0, width: '100%', height: '100%' }}>
                                                <RenderNode nodeId={prevRootId} nodes={prevCueState.nodes} connections={prevCueState.connections} resolution={height} wallColor={wall.color} isLive={isLive} isTransitioning={isTransitioning} />
                                    </div>
                                )}
                                {currentNodeToRender && (
                                    <div key={currRootId} style={{ opacity: currentLayerOpacity, position: 'absolute', inset: 0, width: '100%', height: '100%' }}>
                                        {currentNodeToRender}
                                    </div>
                                )}
                            </div>
                        );
                    })}
                </div>
            );
        };

        // --- NODE EDITOR COMPONENTS ---

        const Node = ({ id, type, x, y, label, selected, onDragStart, onHandleClick, data, updateData, isConnecting, activeConnectionId, onDelete, onOpenAssetBrowser }) => {
            const isMix = type === 'mix';
            const isMedia = type === 'image' || type === 'video';
            const isOutput = type === 'output';
            const isGenerator = type === 'noise';

            return (
                <div
                    className={`absolute w-64 pb-2 rounded-lg border shadow-xl flex flex-col visible bg-zinc-800/95 backdrop-blur-sm ${selected ? 'border-blue-500 ring-1 ring-blue-500' : 'border-zinc-600'}`}
                    style={{ transform: `translate(${x}px, ${y}px)` }}
                >
                    {/* Header - Movable */}
                    <div 
                        className={`px-3 py-2 rounded-t-lg text-xs font-bold uppercase flex justify-between items-center cursor-grab active:cursor-grabbing ${type === 'output' ? 'bg-lime-900 text-lime-200' : isMedia ? 'bg-purple-900 text-purple-200' : isMix ? 'bg-orange-900 text-orange-200' : 'bg-zinc-700 text-gray-300'}`}
                        onMouseDown={(e) => { e.stopPropagation(); onDragStart(e, id); }}
                    >
                        <span className="flex items-center gap-2">
                            {type === 'image' && <ImageIcon size={14}/>}
                            {type === 'video' && <Video size={14}/>}
                            {type === 'color' && <Palette size={14}/>}
                            {type === 'noise' && <Activity size={14}/>}
                            {type === 'mix' && <Blend size={14}/>}
                            {type}
                        </span>
                        <div className="flex items-center gap-2">
                            {data?.name && <span className="truncate max-w-[100px] opacity-70" title={data.name}>{data.name}</span>}
                            
                            {/* ðŸ”´ CHANGE: Only show delete if NOT an output/wall node */}
                            {type !== 'output' && (
                                <button onClick={() => onDelete(id)} className="text-gray-500 hover:text-red-400 transition-colors" title="Delete Node">
                                    <X size={14} />
                                </button>
                            )}
                        </div>
                    </div>
                    
                    {/* Body - Non Movable */}
                    <div className="p-3 space-y-3 cursor-default" onMouseDown={(e) => e.stopPropagation()}>
                        <div className="text-sm font-bold text-gray-200">{label}</div>
                        
                        {type === 'color' && (
                            <input type="color" value={data?.value || '#ffffff'} onChange={(e) => updateData(id, { value: e.target.value })} className="w-full h-10 bg-transparent cursor-pointer border border-zinc-600 rounded" />
                        )}

                        {type === 'mix' && (
                            <div>
                                <select value={data?.blendMode || 'normal'} onChange={(e) => updateData(id, { blendMode: e.target.value })} className="w-full bg-zinc-950 text-sm p-3 border border-zinc-600 rounded text-white font-medium focus:ring-2 focus:ring-blue-500 outline-none cursor-pointer">
                                    <option value="normal">Normal</option>
                                    <option value="multiply">Multiply</option>
                                    <option value="screen">Screen</option>
                                    <option value="overlay">Overlay</option>
                                    <option value="darken">Darken</option>
                                    <option value="lighten">Lighten</option>
                                    <option value="difference">Difference</option>
                                    <option value="add">Add</option>
                                </select>
                            </div>
                        )}
                        
                        {(type === 'image' || type === 'video') && (
                            <div className="space-y-2">
                                <div className="w-full h-24 bg-black border border-zinc-700 rounded overflow-hidden flex items-center justify-center relative group">
                                    {data?.value ? (
                                        type === 'video' ? <video src={data.value} className="w-full h-full object-contain" muted /> : <img src={data.value} className="w-full h-full object-contain" />
                                    ) : (
                                        <div className="text-gray-600 flex flex-col items-center"><Upload size={24}/></div>
                                    )}
                                    <button onClick={() => onOpenAssetBrowser(type, (asset) => updateData(id, { value: asset.url, assetId: asset.id, name: asset.file.name }))} className="absolute inset-0 bg-black/50 opacity-0 group-hover:opacity-100 flex items-center justify-center text-sm transition-opacity font-bold">
                                        <Upload size={16} className="mr-2"/> Load Media
                                    </button>
                                </div>
                            </div>
                        )}
                        
                        {(type === 'image' || type === 'video') && (
                            <div className="space-y-2 border-t border-zinc-700 pt-2">
                                <div className="grid grid-cols-2 gap-2">
                                    <div>
                                        <label className="text-[10px] text-gray-500 font-bold block mb-1">Mode</label>
                                        <select value={data?.fit || 'cover'} onChange={(e) => updateData(id, { fit: e.target.value })} className="w-full bg-zinc-900 text-xs p-1 border border-zinc-700 rounded text-gray-300 outline-none">
                                            <option value="cover">Cover (Zoom)</option>
                                            <option value="contain">Contain (Fit)</option>
                                            <option value="fill">Stretch</option>
                                        </select>
                                    </div>
                                    <div>
                                        <label className="text-[10px] text-gray-500 font-bold block mb-1">Scale: {data?.scale || 1}</label>
                                        <input type="range" min="0.1" max="5" step="0.01" value={data?.scale ?? 1} onChange={(e) => updateData(id, { scale: parseFloat(e.target.value) })} className="w-full h-2 bg-zinc-600 rounded appearance-none cursor-pointer" />
                                    </div>
                                </div>
                                <div>
                                    <label className="text-[10px] text-gray-500 font-bold block mb-1">Rotation: {data?.rotate || 0}Â°</label>
                                    <input type="range" min="-180" max="180" step="1" value={data?.rotate ?? 0} onChange={(e) => updateData(id, { rotate: parseInt(e.target.value) })} className="w-full h-2 bg-zinc-600 rounded appearance-none cursor-pointer" />
                                </div>
                                {data?.fit !== 'fill' && (
                                    <div>
                                        <label className="text-[10px] text-gray-500 font-bold block mb-1">Position ({data?.alignX ?? 50}%, {data?.alignY ?? 50}%)</label>
                                        <div className="flex gap-2">
                                            <input type="range" min="0" max="100" value={data?.alignX ?? 50} onChange={(e) => updateData(id, { alignX: parseInt(e.target.value) })} className="w-full h-2 bg-zinc-600 rounded appearance-none cursor-pointer" title="Horizontal Position" />
                                            <input type="range" min="0" max="100" value={data?.alignY ?? 50} onChange={(e) => updateData(id, { alignY: parseInt(e.target.value) })} className="w-full h-2 bg-zinc-600 rounded appearance-none cursor-pointer" title="Vertical Position" />
                                        </div>
                                    </div>
                                )}
                            </div>
                        )}

                        {isGenerator && (
                             <div className="border-t border-zinc-700 pt-3 mt-2 space-y-2">
                                <div className="flex justify-between items-center">
                                    <label className="text-xs text-gray-400 font-bold">Noise Type</label>
                                    <select value={data?.noiseType || 'perlin'} onChange={(e) => updateData(id, { noiseType: e.target.value })} className="bg-zinc-900 text-xs p-1 px-2 border border-zinc-700 rounded text-gray-300 w-24">
                                        <option value="perlin">Perlin (Soft)</option>
                                        <option value="fbm">Clouds (FBM)</option>
                                        <option value="ridge">Electricity (Ridge)</option>
                                        <option value="worley">Bubbles (Voronoi)</option>
                                        <option value="cells">Cells (Voronoi ID)</option>
                                    </select>
                                </div>
                                <div>
                                    <label className="text-[10px] text-gray-500 block mb-1">Scale: {data?.scale || 5}</label>
                                    <input type="range" min="1" max="100" step="0.5" value={data?.scale ?? 5} onChange={(e) => updateData(id, { scale: parseFloat(e.target.value) })} className="w-full h-2 bg-zinc-600 rounded appearance-none cursor-pointer" />
                                </div>
                                <div>
                                    <label className="text-[10px] text-gray-500 block mb-1">{data?.noiseType === 'fbm' ? 'Octaves' : 'Detail'}: {data?.detail || 4}</label>
                                    <input type="range" min="1" max={data?.noiseType === 'fbm' ? 8 : 10} step={data?.noiseType === 'fbm' ? 1 : 0.5} value={data?.detail ?? 4} onChange={(e) => updateData(id, { detail: parseFloat(e.target.value) })} className="w-full h-2 bg-zinc-600 rounded appearance-none cursor-pointer" />
                                </div>
                                <div>
                                    <label className="text-[10px] text-gray-500 block mb-1">Distortion: {data?.distortion || 0}</label>
                                    <input type="range" min="0" max="5" step="0.1" value={data?.distortion ?? 0} onChange={(e) => updateData(id, { distortion: parseFloat(e.target.value) })} className="w-full h-2 bg-zinc-600 rounded appearance-none cursor-pointer" />
                                </div>
                                <div className="pt-2 border-t border-zinc-700/50">
                                    <div className="flex items-center justify-between">
                                        <label className="text-xs text-gray-400 font-bold">Animate</label>
                                        <input type="checkbox" checked={data?.isAnimating ?? false} onChange={(e) => updateData(id, { isAnimating: e.target.checked })} className="form-checkbox h-4 w-4 text-blue-600 bg-zinc-800 border-zinc-600 rounded focus:ring-blue-500" />
                                    </div>
                                    {data?.isAnimating ? (
                                        <>
                                            <label className="text-[10px] text-gray-500 block mb-1 mt-2">Animation Speed: {data?.animSpeed || 0.1}</label>
                                            <input type="range" min="0" max="1" step="0.01" value={data?.animSpeed ?? 0.1} onChange={(e) => updateData(id, { animSpeed: parseFloat(e.target.value) })} className="w-full h-2 bg-zinc-600 rounded appearance-none cursor-pointer" />
                                        </>
                                    ) : (
                                        <>
                                            <label className="text-[10px] text-gray-500 block mb-1 mt-2">Time</label>
                                            <input type="range" min="0" max="100" step="0.1" value={data?.time ?? 0} onChange={(e) => updateData(id, { time: parseFloat(e.target.value) })} className="w-full h-2 bg-zinc-600 rounded appearance-none cursor-pointer" />
                                        </>
                                    )}
                                </div>
                            </div>
                        )}

                    </div>
                    
                    {/* Handles - Rendered relative to node content */}
                    {!isOutput && <HandleCircle type="output" title="Output" top={50} active={isConnecting && activeConnectionId === id} onClick={(e) => { e.stopPropagation(); onHandleClick(id, 'output'); }} />}
                    {isOutput && <HandleCircle type="input" title="Input" top={50} onClick={(e) => { e.stopPropagation(); onHandleClick(id, 'input'); }} />}
                    
                    {isMix && (
                        <>
                            <HandleCircle type="base" title="Base Layer" top={50} onClick={(e) => { e.stopPropagation(); onHandleClick(id, 'base'); }} />
                            <HandleCircle type="blend" title="Blend Layer" top={90} onClick={(e) => { e.stopPropagation(); onHandleClick(id, 'blend'); }} />
                            <span className="absolute -left-12 top-[54px] text-[10px] text-gray-400 pointer-events-none w-8 text-right font-bold">Base</span>
                            <span className="absolute -left-12 top-[94px] text-[10px] text-gray-400 pointer-events-none w-8 text-right font-bold">Blend</span>
                        </>
                    )}
                </div>
            );
        };

        const NodeEditor = ({ activeSelection, currentCue, updateCueData, walls, setWalls, onOpenAssetBrowser }) => {
            const [nodes, setNodes] = useState([]);
            const [connections, setConnections] = useState([]);
            const [pan, setPan] = useState({ x: 0, y: 0 });
            const [zoom, setZoom] = useState(1);
            const [draggingId, setDraggingId] = useState(null);
            const dragOffset = useRef({ x: 0, y: 0 });
            const [connectSource, setConnectSource] = useState(null); // { id, handle }
            const [contextMenu, setContextMenu] = useState(null);
            const [hoveredConnectionIndex, setHoveredConnectionIndex] = useState(null);

            useEffect(() => {
                let animationFrameId;
                const animateNodes = () => {
                    setNodes(currentNodes => currentNodes.map(n => {
                        if (n.type === 'noise' && n.data.isAnimating) {
                            const newTime = (n.data.time || 0) + (n.data.animSpeed || 0.1);
                            return { ...n, data: { ...n.data, time: newTime } };
                        }
                        return n;
                    }));
                    animationFrameId = requestAnimationFrame(animateNodes);
                };
                animationFrameId = requestAnimationFrame(animateNodes);
                return () => cancelAnimationFrame(animationFrameId);
            }, []);

            useEffect(() => {
                if(currentCue) {
                    if(activeSelection.type === 'transition') {
                        setNodes([ { id: 'n1', type: 'state', x: 50, y: 100, label: 'Prev Cue' }, { id: 'n2', type: 'effect', x: 300, y: 100, label: 'Crossfade' }, { id: 'n3', type: 'state', x: 600, y: 100, label: 'Next Cue' } ]);
                        setConnections([{ from: 'n1', to: 'n2' }, { from: 'n2', to: 'n3' }]);
                    } else {
                        if(currentCue.nodes && currentCue.nodes.length > 0) {
                            setNodes(currentCue.nodes);
                            setConnections(currentCue.connections);
                            const existingWallIds = new Set(currentCue.nodes.filter(n => n.type === 'output').map(n => n.data.wallId));
                            const missingWalls = walls.filter(w => !existingWallIds.has(w.id));
                            if(missingWalls.length > 0) {
                                const newNodes = missingWalls.map((w, i) => ({ id: `wall-${w.id}`, type: 'output', x: 800, y: 50 + ((currentCue.nodes.length + i) * 150), label: w.name, data: { wallId: w.id } }));
                                setNodes(prev => [...prev, ...newNodes]);
                            }
                        } else {
                            const newNodes = walls.map((w, i) => ({ id: `wall-${w.id}`, type: 'output', x: 800, y: 50 + (i * 200), label: w.name, data: { wallId: w.id } }));
                            setNodes(newNodes);
                            setConnections([]);
                        }
                    }
                }
            }, [activeSelection.cueId, activeSelection.type, walls.length]); 

            useEffect(() => {
                if(activeSelection.type === 'cue' && nodes.length > 0) {
                    updateCueData({ nodes, connections });
                }
            }, [nodes, connections]);

            const handleDragStart = (e, id) => {
                e.stopPropagation();
                const node = nodes.find(n => n.id === id);
                dragOffset.current = { x: e.clientX - node.x * zoom - pan.x, y: e.clientY - node.y * zoom - pan.y };
                setDraggingId(id);
                setConnectSource(null); // Cancel connection if dragging starts
            };

            const handleHandleClick = (id, handleType) => {
                if(handleType === 'output') {
                    // Clicked Output
                    if(connectSource?.id === id && connectSource?.handle === 'output') {
                        setConnectSource(null); // toggle off
                    } else {
                        setConnectSource({ id, handle: 'output' });
                    }
                } else {
                    // Clicked Input
                    if(connectSource && connectSource.handle === 'output') {
                        if(connectSource.id !== id) {
                            // Create connection
                            const filtered = connections.filter(c => !(c.to === id && c.toHandle === handleType));
                            setConnections([...filtered, { from: connectSource.id, to: id, toHandle: handleType }]);
                            setConnectSource(null);
                        }
                    }
                }
            };

            const handleMouseMove = (e) => {
                if (draggingId) {
                    const newX = (e.clientX - pan.x - dragOffset.current.x) / zoom;
                    const newY = (e.clientY - pan.y - dragOffset.current.y) / zoom;
                    setNodes(prev => prev.map(n => n.id === draggingId ? { ...n, x: newX, y: newY } : n));
                } else if (e.buttons === 4 || (e.buttons === 1 && e.shiftKey)) {
                    setPan(p => ({ x: p.x + e.movementX, y: p.y + e.movementY }));
                }
            };

            const handleMouseUp = () => setDraggingId(null);
            const handleBgClick = () => { setConnectSource(null); setContextMenu(null); };
            
            const handleWheel = (e) => {
                if (e.ctrlKey) {
                    setZoom(z => Math.min(Math.max(z - e.deltaY * 0.001, 0.5), 2));
                } else {
                    setPan(p => ({ x: p.x - e.deltaX, y: p.y - e.deltaY }));
                }
            };

            const handleContextMenu = (e) => { e.preventDefault(); setContextMenu({ x: e.clientX, y: e.clientY }); };
            
            const addNode = (type, label) => { 
                const id = `n-${Date.now()}`; 
                const centerX = (window.innerWidth / 2 - pan.x) / zoom - 300; 
                const centerY = (200 - pan.y) / zoom; 
                setNodes(prev => [...prev, { id, type, x: centerX, y: centerY, label, data: type === 'color' ? { value: '#ffffff' } : type === 'noise' ? { noiseType: 'fbm', scale: 5, detail: 4, time: 0, distortion: 0, isAnimating: false, animSpeed: 0.05 } : {} }]); 
                setContextMenu(null); 
            };
            
            const handleAddImageNode = () => { addNode('image', 'Image Source'); };
            const updateNodeData = (id, data) => { setNodes(prev => prev.map(n => n.id === id ? { ...n, data: { ...n.data, ...data } } : n)); };
            const deleteConnection = (index) => { setConnections(prev => prev.filter((_, i) => i !== index)); };
            
            const deleteNode = (idToDelete) => {
                const nodeToDelete = nodes.find(n => n.id === idToDelete);
                if (!nodeToDelete) return;

                // Prevent deleting any wall output node
                if (nodeToDelete.type === 'output') {
                    alert("Cannot delete an output node. To remove a wall, delete it from the Geometry panel.");
                    return;
                }

                setNodes(prev => prev.filter(n => n.id !== idToDelete));
                setConnections(prev => prev.filter(c => c.from !== idToDelete && c.to !== idToDelete));
            };

            // REPLACE the existing getHandleOffset function with this updated version
            const getHandleOffset = (node, handle) => {
                if (!node) return { x: 0, y: 0 };
                
                // Standard width of the node card
                const width = 256; 

                // Output handles (Right side)
                if (handle === 'output') return { x: node.x + width + 8, y: node.y + 64 };
                
                // Wall Nodes (Output type) input handle
                if (node.type === 'output') return { x: node.x - 8, y: node.y + 64 };

                // Mix Node handles
                if (handle === 'base') return { x: node.x - 8, y: node.y + 64 };
                if (handle === 'blend') return { x: node.x - 8, y: node.y + 104 };

                // Default for single inputs (Image, Video, etc.)
                return { x: node.x - 8, y: node.y + 64 };
            };

            const getBezierMidpoint = (p0, p1, p2, p3) => {
                 const t = 0.5;
                 const x = (1-t)*(1-t)*(1-t)*p0.x + 3*(1-t)*(1-t)*t*p1.x + 3*(1-t)*t*t*p2.x + t*t*t*p3.x;
                 const y = (1-t)*(1-t)*(1-t)*p0.y + 3*(1-t)*(1-t)*t*p1.y + 3*(1-t)*t*t*p2.y + t*t*t*p3.y;
                 return {x, y};
            };

            return (
                <div className="h-full bg-transparent relative overflow-hidden select-none" onMouseMove={handleMouseMove} onMouseUp={handleMouseUp} onMouseLeave={handleMouseUp} onWheel={handleWheel} onContextMenu={handleContextMenu} onClick={handleBgClick}>
                    <div className="absolute inset-0 node-grid opacity-30" style={{ transform: `translate(${pan.x}px, ${pan.y}px) scale(${zoom})`, transformOrigin: '0 0' }}></div>
                    <div className="absolute top-2 left-2 z-10 flex gap-2 pointer-events-none">
                        <div className="bg-zinc-800/80 backdrop-blur border border-zinc-700 rounded p-2 flex items-center gap-2 shadow-lg pointer-events-auto">
                            <Workflow size={14} className="text-purple-400" />
                            <span className="text-xs font-bold text-gray-300">{activeSelection.type === 'transition' ? 'Transition Logic' : 'Content Graph'}</span>
                            {activeSelection.type === 'cue' && (
                                <>
                                    <div className="w-px h-4 bg-zinc-600 mx-1"></div>
                                    <button onClick={handleAddImageNode} className="flex items-center gap-1 bg-purple-700 hover:bg-purple-600 text-white text-[10px] px-2 py-1 rounded transition-colors"> <Plus size={10}/> Add Image </button>
                                    <button onClick={() => addNode('video', 'Video')} className="flex items-center gap-1 bg-pink-700 hover:bg-pink-600 text-white text-[10px] px-2 py-1 rounded transition-colors"> <Video size={10}/> Add Video </button>
                                    <button onClick={() => addNode('color', 'Color')} className="flex items-center gap-1 bg-sky-700 hover:bg-sky-600 text-white text-[10px] px-2 py-1 rounded transition-colors"> <Palette size={10}/> Add Color </button>
                                    <button onClick={() => addNode('mix', 'Mixer')} className="flex items-center gap-1 bg-orange-700 hover:bg-orange-600 text-white text-[10px] px-2 py-1 rounded transition-colors"> <Blend size={10}/> Add Mix </button>
                                    <button onClick={() => addNode('noise', 'Noise')} className="flex items-center gap-1 bg-teal-700 hover:bg-teal-600 text-white text-[10px] px-2 py-1 rounded transition-colors"> <Activity size={10}/> Add Noise </button>
                                    <div className="text-[10px] text-gray-500 ml-2">Click handles to connect</div>
                                </>
                            )}
                        </div>
                    </div>
                    {contextMenu && activeSelection.type === 'cue' && (
                        <div className="absolute z-50 bg-zinc-800 border border-zinc-600 rounded shadow-xl py-1 w-32" style={{top: contextMenu.y - 40, left: contextMenu.x}}>
                            <div className="px-2 py-1 text-[10px] text-gray-500 font-bold uppercase">Add Node</div>
                            <button onClick={() => addNode('image', 'Image Source')} className="w-full text-left px-3 py-1.5 text-xs text-white hover:bg-purple-600 flex gap-2"><ImageIcon size={12}/> Image</button>
                            <button onClick={() => addNode('video', 'Video Source')} className="w-full text-left px-3 py-1.5 text-xs text-white hover:bg-purple-600 flex gap-2"><Video size={12}/> Video</button>
                            <button onClick={() => addNode('color', 'Color Source')} className="w-full text-left px-3 py-1.5 text-xs text-white hover:bg-purple-600 flex gap-2"><Palette size={12}/> Color</button>
                            <button onClick={() => addNode('noise', 'Noise Generator')} className="w-full text-left px-3 py-1.5 text-xs text-white hover:bg-purple-600 flex gap-2"><Activity size={12}/> Noise</button>
                            <div className="w-full h-px bg-zinc-700 my-1"></div>
                            <button onClick={() => addNode('mix', 'Mix / Mask')} className="w-full text-left px-3 py-1.5 text-xs text-white hover:bg-orange-600 flex gap-2"><Blend size={12}/> Mixer</button>
                        </div>
                    )}
                    <div style={{ transform: `translate(${pan.x}px, ${pan.y}px) scale(${zoom})`, transformOrigin: '0 0', width: '100%', height: '100%' }}>
                        <svg className="absolute inset-0 overflow-visible pointer-events-auto">
                            {connections.map((conn, i) => {
                                const fromNode = nodes.find(n => n.id === conn.from);
                                const toNode = nodes.find(n => n.id === conn.to);
                                if(!fromNode || !toNode) return null;
                                
                                const start = getHandleOffset(fromNode, 'output');
                                const end = getHandleOffset(toNode, conn.toHandle || 'input'); 

                                const cp1x = start.x + (end.x - start.x) / 2; 
                                const cp2x = end.x - (end.x - start.x) / 2;
                                
                                const isHovered = hoveredConnectionIndex === i;
                                const mid = getBezierMidpoint({x:start.x, y:start.y}, {x:cp1x, y:start.y}, {x:cp2x, y:end.y}, {x:end.x, y:end.y});

                                return (
                                    <g key={i} onMouseEnter={() => setHoveredConnectionIndex(i)} onMouseLeave={() => setHoveredConnectionIndex(null)}>
                                        <path d={`M ${start.x} ${start.y} C ${cp1x} ${start.y}, ${cp2x} ${end.y}, ${end.x} ${end.y}`} fill="none" stroke="transparent" strokeWidth="20" />
                                        <path d={`M ${start.x} ${start.y} C ${cp1x} ${start.y}, ${cp2x} ${end.y}, ${end.x} ${end.y}`} fill="none" stroke={isHovered ? "#ef4444" : "#555"} strokeWidth="2" />
                                        {isHovered && (
                                            <foreignObject x={mid.x - 12} y={mid.y - 12} width="24" height="24" className="overflow-visible">
                                                <div 
                                                    className="w-6 h-6 bg-red-600 rounded-full flex items-center justify-center cursor-pointer hover:scale-125 transition-transform shadow-lg"
                                                    onClick={(e) => { e.stopPropagation(); deleteConnection(i); }}
                                                    title="Remove Connection"
                                                >
                                                    <Trash2 size={12} className="text-white"/>
                                                </div>
                                            </foreignObject>
                                        )}
                                    </g>
                                );
                            })}
                            {connectSource && (
                                (() => {
                                    const fromNode = nodes.find(n => n.id === connectSource.id);
                                    if(fromNode) {
                                        const start = getHandleOffset(fromNode, 'output');
                                        return <circle cx={start.x} cy={start.y} r="4" fill="white" />;
                                    }
                                })()
                            )}
                        </svg>
                        {nodes.map(node => ( <div key={node.id}><Node id={node.id} {...node} selected={draggingId === node.id} isConnecting={!!connectSource} activeConnectionId={connectSource?.id} onDragStart={handleDragStart} onHandleClick={handleHandleClick} updateData={updateNodeData} onDelete={deleteNode} onOpenAssetBrowser={onOpenAssetBrowser} /></div>))}
                    </div>
                </div>
            );
        };

        const WallStackVisualizer = ({ walls, activeWallId }) => {
            if (walls.length === 0) return null;

            return (
                <div className="mt-4 pt-4 border-t border-zinc-700">
                    <h3 className="text-xs font-bold text-gray-500 mb-3 flex items-center gap-1"><Layers size={12}/> STACKING ORDER (TOP &rarr; BOTTOM)</h3>
                    <div className="relative h-24 bg-zinc-800/50 rounded-lg p-4 flex items-center justify-start overflow-x-auto">
                        {walls.slice().reverse().map((wall, index) => (
                            <div
                                key={wall.id}
                                title={`${wall.name} (Stack position ${walls.length - index})`}
                                className={`absolute w-12 h-12 rounded border-2 transition-all duration-300 ease-out flex items-center justify-center text-white font-bold text-xs shadow-md ${wall.id === activeWallId ? 'border-blue-400 ring-2 ring-blue-500/50' : 'border-zinc-600 hover:border-zinc-400'}`}
                                style={{
                                    backgroundColor: wall.color,
                                    left: `${10 + index * 15}%`,
                                    zIndex: walls.length - index,
                                    transform: `translateY(${wall.id === activeWallId ? '-8px' : '0px'}) scale(${wall.id === activeWallId ? '1.1' : '1'})`
                                }}
                            >
                                {walls.length - index}
                            </div>
                        ))}
                    </div>
                </div>
            );
        };

        const WallItem = ({ wall, activeWallId, setActiveWallId, moveWall, deleteWall }) => {
            return (
                <div 
                    onClick={() => setActiveWallId(wall.id)} 
                    className={`flex justify-between items-center p-2 rounded text-xs cursor-pointer ${wall.id === activeWallId ? 'bg-zinc-700 text-white border border-zinc-600' : 'text-gray-400 hover:bg-zinc-800/50'}`}
                >
                    <div className="flex items-center gap-2 truncate">
                        <div className="w-2 h-2 rounded-full flex-shrink-0" style={{ backgroundColor: wall.color }}></div>
                        <span className="truncate">{wall.name}</span>
                    </div>
                    <div className="flex items-center gap-2 flex-shrink-0">
                        <div className="flex flex-col -my-1">
                            <button onClick={(e) => {e.stopPropagation(); moveWall(wall.id, -1)}} className="p-0.5 rounded hover:bg-zinc-600 text-gray-400 hover:text-white" title="Move Up"><ChevronUp size={16}/></button>
                            <button onClick={(e) => {e.stopPropagation(); moveWall(wall.id, 1)}} className="p-0.5 rounded hover:bg-zinc-600 text-gray-400 hover:text-white" title="Move Down"><ChevronDown size={16}/></button>
                        </div>
                        <button onClick={(e) => {e.stopPropagation(); deleteWall(wall.id, wall.name)}} className="p-1 rounded hover:bg-red-900/50 text-gray-500 hover:text-red-400" title="Delete Wall"><Trash2 size={14}/></button>
                    </div>
                </div>
            );
        };

        const FolderItem = ({ folder, walls, activeWallId, setActiveWallId, setWalls, setFolders, moveWall, deleteWall }) => {
            const folderWalls = walls.filter(w => w.folderId === folder.id);
            return (
                <div className="mb-2">
                    <div className="flex items-center gap-2 p-2 bg-zinc-800 hover:bg-zinc-700 rounded cursor-pointer text-xs font-bold text-gray-300" onClick={() => setFolders(prev => prev.map(f => f.id === folder.id ? {...f, isOpen: !f.isOpen} : f))}>
                        {folder.isOpen ? <ChevronDown size={14}/> : <ChevronRight size={14}/>} <Folder size={14} className="text-blue-400" /> {folder.name} <span className="ml-auto text-[10px] text-gray-500">{folderWalls.length}</span>
                        <button onClick={(e) => {e.stopPropagation(); if (confirm(`Delete folder "${folder.name}"? Walls inside will be ungrouped.`)) { setFolders(prev => prev.filter(f => f.id !== folder.id)); setWalls(prev => prev.map(w => w.folderId === folder.id ? {...w, folderId: null} : w)) }}} className="text-gray-500 hover:text-red-400 ml-2"><Trash2 size={12}/></button>
                    </div>
                    {folder.isOpen && (
                        <div className="ml-2 pl-2 border-l border-zinc-700 mt-1 space-y-1">
                            {folderWalls.map(wall => (
                                <WallItem key={wall.id} wall={wall} activeWallId={activeWallId} setActiveWallId={setActiveWallId} moveWall={moveWall} deleteWall={deleteWall} />
                            ))}
                            {folderWalls.length === 0 && <div className="text-[10px] text-gray-600 p-2 italic">Empty Folder</div>}
                        </div>
                    )}
                </div>
            );
        };

        const getEase = (t, type) => {
            if (t < 0) return 0;
            if (t > 1) return 1;
            switch (type) {
                case 'easeIn': return t * t;
                case 'easeOut': return t * (2 - t);
                case 'easeInOut': return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
                default: return t;
            }
        };

        const TransitionEditor = ({ cue, updateCue }) => {
            if (!cue) return <div className="h-full flex items-center justify-center text-gray-500 text-xs">Select a transition to edit</div>;

            const duration = cue.transitionDuration ?? 1.0;
            const delay = cue.transitionDelay ?? 0.0;
            const ease = cue.transitionEase || 'linear';

            const width = 600; const height = 200; const padding = 40;
            const graphW = width - padding * 2; const graphH = height - padding * 2;
            const totalTime = Math.max(duration + delay + 1, 5);
            const steps = 100;
            const points = [];
            for (let i = 0; i <= steps; i++) {
                const t = (i / steps) * totalTime;
                let val = 0;
                if (t >= delay) { const localT = duration > 0 ? (t - delay) / duration : 1; val = getEase(localT, ease); }
                const x = padding + (t / totalTime) * graphW; const y = height - padding - (val * graphH);
                points.push(`${x},${y}`);
            }

            return (
                <div className="w-full h-full bg-transparent p-6 flex gap-8 text-gray-300">
                    <div className="w-64 flex flex-col gap-6 pt-2">
                        <div><h3 className="text-sm font-bold text-white mb-4 flex items-center gap-2"><Link size={16}/> TRANSITION SETTINGS</h3>
                            <div className="space-y-4">
                                <div><div className="flex justify-between mb-1"><label className="text-xs font-bold">Duration</label><span className="text-xs font-mono text-blue-400">{duration.toFixed(1)}s</span></div><input type="range" min="0" max="10" step="0.1" value={duration} onChange={(e) => updateCue({ transitionDuration: parseFloat(e.target.value) })} className="w-full h-2 bg-zinc-700 rounded-lg appearance-none cursor-pointer accent-blue-500" /></div>
                                <div><div className="flex justify-between mb-1"><label className="text-xs font-bold">Delay</label><span className="text-xs font-mono text-orange-400">{delay.toFixed(1)}s</span></div><input type="range" min="0" max="5" step="0.1" value={delay} onChange={(e) => updateCue({ transitionDelay: parseFloat(e.target.value) })} className="w-full h-2 bg-zinc-700 rounded-lg appearance-none cursor-pointer accent-orange-500" /></div>
                                <div><label className="text-xs font-bold block mb-2">Easing Curve</label><div className="grid grid-cols-2 gap-2">{['linear', 'easeIn', 'easeOut', 'easeInOut'].map(e => (<button key={e} onClick={() => updateCue({ transitionEase: e })} className={`px-3 py-2 rounded text-xs font-medium border transition-all ${ease === e ? 'bg-blue-600 border-blue-500 text-white' : 'bg-zinc-800 border-zinc-700 hover:bg-zinc-700'}`}>{e.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase())}</button>))}</div></div>
                            </div>
                        </div>
                    </div>
                    <div className="flex-1 bg-zinc-950 rounded-xl border border-zinc-800 relative shadow-inner overflow-hidden">
                        <div className="absolute top-3 left-4 text-[10px] font-mono text-zinc-500">OPACITY / TIME</div>
                        <svg width="100%" height="100%" viewBox={`0 0 ${width} ${height}`} preserveAspectRatio="none" className="absolute inset-0">
                            <line x1={padding} y1={height-padding} x2={width-padding} y2={height-padding} stroke="#333" strokeWidth="1" />
                            <line x1={padding} y1={padding} x2={padding} y2={height-padding} stroke="#333" strokeWidth="1" />
                            <path d={`M ${points.join(' L ')}`} fill="none" stroke="#60a5fa" strokeWidth="3" strokeLinecap="round" />
                            <path d={`M ${points[0]} L ${points.join(' L ')} L ${points[points.length-1].split(',')[0]},${height-padding} Z`} fill="url(#gradient)" opacity="0.2" />
                            <defs><linearGradient id="gradient" x1="0" y1="0" x2="0" y2="1"><stop offset="0%" stopColor="#60a5fa" /><stop offset="100%" stopColor="transparent" /></linearGradient></defs>
                            <line x1={padding + (delay / totalTime) * graphW} y1={padding} x2={padding + (delay / totalTime) * graphW} y2={height-padding} stroke="#fb923c" strokeWidth="1" strokeDasharray="4,4" />
                            <line x1={padding + ((delay + duration) / totalTime) * graphW} y1={padding} x2={padding + ((delay + duration) / totalTime) * graphW} y2={height-padding} stroke="#fb923c" strokeWidth="1" strokeDasharray="4,4" />
                        </svg>
                    </div>
                </div>
            );
        };

        const App = () => {
            const [walls, setWalls] = useState([{ id: 1, name: "Main Wall", color: "#84cc16", folderId: null, points: [{ x: 100, y: 100 }, { x: 500, y: 100 }, { x: 500, y: 325 }, { x: 100, y: 325 }] }]);
            const [folders, setFolders] = useState([]); 
            const [activeWallId, setActiveWallId] = useState(1);
            const [menuOpen, setMenuOpen] = useState(false);
            const [viewMode, setViewMode] = useState('2d'); 
            const [showGuides, setShowGuides] = useState(false); 
            const [showTexture, setShowTexture] = useState(true); 
            const [moveMode, setMoveMode] = useState(false);
            const fileInputRef = useRef(null);
            const [isFullscreen, setIsFullscreen] = useState(false);
            const [showNodeEditor, setShowNodeEditor] = useState(true);
            const [storageUsage, setStorageUsage] = useState(null);
            const [assetBrowserState, setAssetBrowserState] = useState({ isOpen: false, type: 'image', callback: null });
            
            // --- SCENE & TRANSITION STATE ---
            const [menuTab, setMenuTab] = useState('config'); 
            const [scenes, setScenes] = useState([{ id: 1, name: "Act 1", cues: [{ id: 1, name: "Cue 1 (Intro)", type: 'standard', transitionDuration: 1.0, animationType: 'static', nodes: null, connections: null }] }]);
            const [activeState, setActiveState] = useState({ sceneId: 1, cueId: 1 });
            const [activeSelection, setActiveSelection] = useState({ type: 'cue', sceneId: 1, cueId: 1 });
            
            // Engine States
            const [transitionMix, setTransitionMix] = useState(1);
            const [prevCueState, setPrevCueState] = useState(null);
            const [currentCueState, setCurrentCueState] = useState(null);
            const requestRef = useRef();
            const startTimeRef = useRef();
            const saveTimeoutRef = useRef();

            // Auto-hide textures/guides when entering scenes
            const prevMenuTabRef = useRef(menuTab);
            const [lastDisplayState, setLastDisplayState] = useState(null);

            useEffect(() => {
                if (prevMenuTabRef.current !== 'scenes' && menuTab === 'scenes') {
                    setLastDisplayState({ showTexture, showGuides, moveMode });
                    setShowTexture(false);
                    setShowGuides(false);
                    setMoveMode(false);
                } else if (prevMenuTabRef.current === 'scenes' && menuTab !== 'scenes') {
                    if (lastDisplayState) {
                        setShowTexture(lastDisplayState.showTexture);
                        setShowGuides(lastDisplayState.showGuides);
                        setMoveMode(lastDisplayState.moveMode);
                        setLastDisplayState(null);
                    }
                }
                prevMenuTabRef.current = menuTab;
            }, [menuTab, showTexture, showGuides, moveMode, lastDisplayState]);

            // Load Data on Startup
            useEffect(() => {
                const loadData = async () => {
                    try {
                        const savedState = await db.loadState('project_data_v22');
                        if (savedState) {
                            setWalls(savedState.walls || []);
                            setFolders(savedState.folders || []);
                            
                            // Restore Asset URLs in Scenes
                            const restoredScenes = await Promise.all(savedState.scenes.map(async (scene) => {
                                const restoredCues = await Promise.all(scene.cues.map(async (cue) => {
                                    // Restore nodes assets
                                    if(cue.nodes) {
                                        cue.nodes = await Promise.all(cue.nodes.map(async (n) => {
                                            if (n.data?.assetId) {
                                                // Use server URL directly
                                                n.data.value = '/api/asset/' + n.data.assetId;
                                            }
                                            return n;
                                        }));
                                    }
                                    return cue;
                                }));
                                return { ...scene, cues: restoredCues };
                            }));
                            setScenes(restoredScenes);
                        }
                        const usage = await db.getUsage();
                        setStorageUsage(usage);
                    } catch (e) {
                        console.error("Failed to load state", e);
                    }
                };
                loadData();
            }, []);

            // Auto-Save Effect
            useEffect(() => {
                if (saveTimeoutRef.current) clearTimeout(saveTimeoutRef.current);
                saveTimeoutRef.current = setTimeout(async () => {
                    await db.saveState('project_data_v22', { walls, folders, scenes });
                    const usage = await db.getUsage();
                    setStorageUsage(usage);
                }, 1000); // Debounce 1s
                return () => clearTimeout(saveTimeoutRef.current);
            }, [walls, folders, scenes]);

            useEffect(() => {
                const handleFsChange = () => setIsFullscreen(!!document.fullscreenElement);
                document.addEventListener('fullscreenchange', handleFsChange);
                return () => document.removeEventListener('fullscreenchange', handleFsChange);
                const attemptFullscreen = async () => {
                    try {
                        if (!document.fullscreenElement) {
                            await document.documentElement.requestFullscreen();
                        }
                    } catch (e) {
                        console.log("Auto-fullscreen blocked:", e);
                    }
                };
                attemptFullscreen();
                const handleClick = () => { attemptFullscreen(); window.removeEventListener('click', handleClick); };
                window.addEventListener('click', handleClick);
                return () => window.removeEventListener('click', handleClick);
            }, []);

            const enterFullscreen = () => { document.documentElement.requestFullscreen().catch(e => console.log(e)); };
            const getCueData = (sId, cId) => { const s = scenes.find(x => x.id === sId); return s ? s.cues.find(x => x.id === cId) : null; };
            const targetCueId = activeSelection.type === 'cue' ? activeSelection.cueId : activeSelection.nextCueId;
            const currentCueObj = useMemo(() => getCueData(activeSelection.sceneId, targetCueId), [activeSelection, scenes]);

            const currentSceneIndex = useMemo(() => scenes.findIndex(s => s.id === activeSelection.sceneId), [scenes, activeSelection.sceneId]);
            const currentCueIndex = useMemo(() => {
                const scene = scenes[currentSceneIndex];
                if (!scene) return -1;
                return scene.cues.findIndex(c => c.id === targetCueId);
            }, [currentSceneIndex, scenes, targetCueId]);


            const updateCueData = (newData) => {
                setScenes(prev => prev.map(s => {
                    if(s.id !== activeSelection.sceneId) return s;
                    return { ...s, cues: s.cues.map(c => { if(c.id !== targetCueId) return c; return { ...c, ...newData }; }) }
                }));
            };

            const animateTransition = (time) => {
                if (!startTimeRef.current) startTimeRef.current = time;
                const duration = (currentCueObj?.transitionDuration || 0) * 1000;
                const delay = (currentCueObj?.transitionDelay || 0) * 1000;
                const totalDuration = duration + delay;
                
                const elapsed = time - startTimeRef.current;
                
                let mix = 1;
                if (totalDuration > 0) {
                    if (elapsed < delay) mix = 0;
                    else mix = duration > 0 ? Math.min((elapsed - delay) / duration, 1) : 1;
                }
                
                const ease = currentCueObj?.transitionEase || 'linear';
                setTransitionMix(getEase(mix, ease));

                if (elapsed < totalDuration) { requestRef.current = requestAnimationFrame(animateTransition); }
                else { setTransitionMix(1); setPrevCueState(null); }
            };

            useEffect(() => {
                let isMounted = true;
                if (currentCueObj) {
                    // Snapshot current state if mid-transition to prevent flickering
                    const startState = (prevCueState && transitionMix < 1) 
                        ? { 
                            ...currentCueState, 
                            nodes: currentCueState.nodes.map(n => {
                                const prev = prevCueState.nodes?.find(pn => pn.id === n.id);
                                return prev ? getInterpolatedNode(prev, n, transitionMix) : n;
                            })
                          }
                        : (currentCueState || prevCueState);

                    const prepareTransition = async () => {
                        // Preload videos
                        const videos = currentCueObj.nodes?.filter(n => n.type === 'video' && n.data?.value) || [];
                        if (videos.length > 0) {
                            await Promise.all(videos.map(n => new Promise(resolve => {
                                const v = document.createElement('video');
                                v.src = n.data.value;
                                v.preload = 'auto';
                                v.onloadeddata = () => resolve();
                                v.onerror = () => resolve();
                                setTimeout(resolve, 1000);
                            })));
                        }
                        
                        if (isMounted) {
                            setPrevCueState(startState);
                            setCurrentCueState(currentCueObj);
                            startTimeRef.current = null;
                            cancelAnimationFrame(requestRef.current);
                            requestRef.current = requestAnimationFrame(animateTransition);
                        }
                    };
                    prepareTransition();
                }
                return () => { isMounted = false; cancelAnimationFrame(requestRef.current); };
            }, [targetCueId, activeSelection.sceneId]); 

            useEffect(() => { if (activeSelection.type === 'cue') setCurrentCueState(currentCueObj); }, [scenes]); 

            useEffect(() => {
                const handleKeyDown = (e) => { 
                    const k = e.key.toLowerCase();
                    if (k === 'h') { if (viewMode === 'live') { setViewMode('2d'); setMenuOpen(true); } else { setMenuOpen(p => !p); } }
                    if (k === 'm' && viewMode !== 'live') setShowGuides(p => !p); 
                    if (k === 't' && viewMode === '2d') setShowTexture(p => !p); 
                    if (k === 'w' && viewMode === '2d') setMoveMode(p => !p);
                    if ((viewMode === 'live' || menuTab === 'scenes') && (k === 'z' || k === 'v' || e.key === 'ArrowRight' || e.key === 'ArrowLeft')) {
                        navigateCue((k === 'z' || e.key === 'ArrowRight') ? 1 : -1);
                    }
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [viewMode, menuTab, activeState, scenes, activeSelection]);

            const moveScene = (index, direction) => {
                setScenes(prev => {
                    const newScenes = [...prev];
                    if (index + direction < 0 || index + direction >= newScenes.length) return prev;
                    [newScenes[index], newScenes[index + direction]] = [newScenes[index + direction], newScenes[index]];
                    return newScenes;
                });
            };

            const moveCue = (sceneId, cueIndex, direction) => {
                setScenes(prev => prev.map(s => {
                    if (s.id !== sceneId) return s;
                    const newCues = [...s.cues];
                    if (cueIndex + direction < 0 || cueIndex + direction >= newCues.length) return s;
                    [newCues[cueIndex], newCues[cueIndex + direction]] = [newCues[cueIndex + direction], newCues[cueIndex]];
                    return { ...s, cues: newCues };
                }));
            };

            const deleteScene = (sceneId) => {
                if (confirm("Delete this Act and all its cues?")) {
                    setScenes(prev => prev.filter(s => s.id !== sceneId));
                }
            };

            const deleteCue = (sceneId, cueId) => {
                if (confirm("Delete this cue?")) {
                    setScenes(prev => prev.map(s => {
                        if (s.id !== sceneId) return s;
                        return { ...s, cues: s.cues.filter(c => c.id !== cueId) };
                    }));
                }
            };

            const navigateCue = (direction) => {
                let flatList = [];
                scenes.forEach(s => { s.cues.forEach(c => { flatList.push({ sceneId: s.id, cueId: c.id }); }); });
                const currentIndex = flatList.findIndex(i => i.sceneId === activeSelection.sceneId && i.cueId === targetCueId);
                if (currentIndex === -1) return;
                let nextIndex = currentIndex + direction;
                if (nextIndex >= 0 && nextIndex < flatList.length) { setActiveSelection({ type: 'cue', ...flatList[nextIndex] }); }
            };

            const updatePoint = (wallId, pointIndex, cx, cy) => { setWalls(prev => prev.map(w => { if (w.id !== wallId) return w; const currentPoints = [...w.points]; if (moveMode) { const prevX = currentPoints[pointIndex].x; const prevY = currentPoints[pointIndex].y; const dx = cx - prevX; const dy = cy - prevY; const newPoints = currentPoints.map(p => ({ x: p.x + dx, y: p.y + dy })); return { ...w, points: newPoints }; } else { currentPoints[pointIndex] = { x: cx, y: cy }; return { ...w, points: currentPoints }; } })); };
            const addFolder = () => { const newId = Math.max(0, ...folders.map(f => f.id)) + 1; setFolders(prev => [...prev, {id: newId, name: `Group ${newId}`, isOpen: true}]); };
            const addScene = () => { const newId = Math.max(0, ...scenes.map(s => s.id)) + 1; setScenes(prev => [...prev, { id: newId, name: `Act ${newId}`, cues: [{ id: 1, name: "Cue 1", type: 'standard' }] }]); };
            const addCue = (sceneId) => { setScenes(prev => prev.map(s => { if (s.id !== sceneId) return s; const newCueId = Math.max(0, ...s.cues.map(c => c.id)) + 1; return { ...s, cues: [...s.cues, { id: newCueId, name: `Cue ${newCueId}`, type: 'standard' }] }; })); };
            const resetData = async () => { if(confirm("This will delete all saved data and images. Are you sure?")) { await db.clearAll(); window.location.reload(); } };

            const deleteWall = (id, name) => {
                if (confirm(`Are you sure you want to delete the wall "${name}"?`)) {
                    setWalls(p => p.filter(w => w.id !== id));
                }
            };

            const moveWall = (id, direction) => {
                setWalls(prev => {
                    const index = prev.findIndex(w => w.id === id);
                    if (index === -1) return prev;
                    const newIndex = index + direction;
                    if (newIndex < 0 || newIndex >= prev.length) return prev;
                    const newWalls = [...prev];
                    [newWalls[index], newWalls[newIndex]] = [newWalls[newIndex], newWalls[index]];
                    return newWalls;
                });
            };

            const activeWall = walls.find(w => w.id === activeWallId);

            // --- RENDERER with TRANSITION LOGIC ---
            const renderSVG = (isLive) => (
                <svg className="w-full h-full" style={{backgroundColor: (showTexture || isLive || menuTab === 'scenes') ? 'black' : 'transparent'}}>
                    {/* ... (SVG Defs and Grid Patterns omitted for brevity but present in rendering) ... */}
                    <defs>
                         <pattern id="smallGrid" width="20" height="20" patternUnits="userSpaceOnUse"><path d="M 20 0 L 0 0 0 20" fill="none" stroke="rgba(255,255,255,0.1)" strokeWidth="0.5"/></pattern>
                         <pattern id="grid" width="100" height="100" patternUnits="userSpaceOnUse"><rect width="100" height="100" fill="url(#smallGrid)"/><path d="M 100 0 L 0 0 0 100" fill="none" stroke="rgba(255,255,255,0.2)" strokeWidth="1"/></pattern>
                    </defs>
                    {showGuides && !isLive && menuTab !== 'scenes' && (<><rect width="100%" height="100%" fill="url(#grid)" pointerEvents="none" /><line x1="50%" y1="0" x2="50%" y2="100%" stroke="cyan" strokeOpacity="0.5" strokeDasharray="5,5" pointerEvents="none" /><line x1="0" y1="50%" x2="100%" y2="50%" stroke="cyan" strokeOpacity="0.5" strokeDasharray="5,5" pointerEvents="none" /></>)}
                    {walls.map(wall => {
                        const getWallStyle = (cueState) => {
                            if (!cueState) return { fill: wall.color, stroke: isLive ? 'none' : wall.color };
                            return { fill: wall.color, stroke: isLive ? 'none' : wall.color };
                        };
                        const currStyle = getWallStyle(currentCueState);
                        const baseOpacity = isLive ? 1 : (wall.id === activeWallId ? 0.5 : 0.1);
                        
                        const isProjecting = (isLive || showTexture || menuTab === 'scenes') && currentCueState?.nodes?.some(n => n.type === 'output' && n.data.wallId === wall.id && currentCueState.connections?.some(c => c.to === n.id));
                        
                        return (
                            <g key={wall.id} onClick={(e) => { if(!isLive) { e.stopPropagation(); setActiveWallId(wall.id); }}}>
                                {isProjecting && ( <path d={`M ${wall.points[0].x} ${wall.points[0].y} L ${wall.points[1].x} ${wall.points[1].y} L ${wall.points[2].x} ${wall.points[2].y} L ${wall.points[3].x} ${wall.points[3].y} Z`} fill="transparent" stroke="none" /> )}
                                {!isProjecting && (isLive || showTexture || menuTab === 'scenes') && ( <path d={`M ${wall.points[0].x} ${wall.points[0].y} L ${wall.points[1].x} ${wall.points[1].y} L ${wall.points[2].x} ${wall.points[2].y} L ${wall.points[3].x} ${wall.points[3].y} Z`} fill={currStyle.fill} fillOpacity={baseOpacity} stroke="none" /> )}
                                {(!isLive && !showTexture && menuTab !== 'scenes') && ( <path d={`M ${wall.points[0].x} ${wall.points[0].y} L ${wall.points[1].x} ${wall.points[1].y} L ${wall.points[2].x} ${wall.points[2].y} L ${wall.points[3].x} ${wall.points[3].y} Z`} fill={currStyle.fill} fillOpacity={baseOpacity} stroke={currStyle.stroke} strokeWidth={wall.id === activeWallId ? 2 : 1} strokeDasharray="5,5" /> )}
                                {((isLive && currentCueObj?.type === 'test') || (!isLive && showTexture)) && <WarpedTextureGrid wallPoints={wall.points} />}
                                {(!isLive && (wall.id === activeWallId) && !showTexture && menuTab !== 'scenes') && wall.points.map((p, i) => ( <PointHandle key={`handle-${wall.id}-${i}`} index={i} x={p.x} y={p.y} color={wall.color} isSelected={true} onDrag={(idx, x, y) => updatePoint(wall.id, idx, x, y)} isMoveMode={moveMode} /> ))}
                                {showGuides && !isLive && menuTab !== 'scenes' && wall.points.map((p, i) => ( <text key={`guide-lbl-${i}`} x={p.x + 12} y={p.y + 4} fill="lime" fontSize="9" fontFamily="monospace" className="pointer-events-none select-none shadow-black drop-shadow-md" style={{textShadow: '1px 1px 0 #000'}}> {Math.round(p.x)},{Math.round(p.y)} </text> ))}
                                {showGuides && !isLive && menuTab !== 'scenes' && ( <g pointerEvents="none"> <line x1={wall.points[0].x} y1={wall.points[0].y} x2={wall.points[2].x} y2={wall.points[2].y} stroke="cyan" strokeWidth="1" strokeOpacity="0.5" strokeDasharray="4,4" /> <line x1={wall.points[1].x} y1={wall.points[1].y} x2={wall.points[3].x} y2={wall.points[3].y} stroke="cyan" strokeWidth="1" strokeOpacity="0.5" strokeDasharray="4,4" /> </g> )}
                            </g>
                        );
                    })}
                    {(!isLive && activeWall && !showTexture && menuTab !== 'scenes') && activeWall.points.map((p, i) => ( <PointHandle key={`handle-${activeWall.id}-${i}`} index={i} x={p.x} y={p.y} color={activeWall.color} isSelected={true} onDrag={(idx, x, y) => updatePoint(activeWall.id, idx, x, y)} isMoveMode={moveMode} /> ))}
                </svg>
            );

            const handleOpenAssetBrowser = (type, callback) => {
                setAssetBrowserState({ isOpen: true, type, callback });
            };

            const handleAssetSelect = (asset) => {
                if (assetBrowserState.callback) assetBrowserState.callback(asset);
                setAssetBrowserState(prev => ({ ...prev, isOpen: false }));
            };

            return (
                <div className="w-full h-full relative font-sans text-white bg-zinc-950 flex flex-col">
                    {!isFullscreen && (
                        <div className="absolute inset-0 z-[100] bg-black/80 backdrop-blur-sm flex flex-col items-center justify-center text-center p-8">
                            <div className="max-w-4xl space-y-8">
                                <img src="robotic T M.png" className="w-[600px] mx-auto mb-8" alt="Logo" />
                                <h1 className="text-5xl font-bold text-white mb-4">Emap</h1>
                                <p className="text-gray-300 text-xl">This application works best in full screen mode.</p>
                                <button onClick={enterFullscreen} className="bg-blue-600 hover:bg-blue-500 text-white px-8 py-4 rounded-xl font-bold text-2xl transition-transform hover:scale-105 flex items-center justify-center gap-3 mx-auto">
                                    <Maximize size={28} /> Start
                                </button>
                            </div>
                        </div>
                    )}

                    <AssetBrowser isOpen={assetBrowserState.isOpen} onClose={() => setAssetBrowserState(prev => ({ ...prev, isOpen: false }))} onSelect={handleAssetSelect} initialTab={assetBrowserState.type} />

                    {viewMode !== 'live' && (
                        <div className="absolute top-16 right-4 pointer-events-none select-none z-50 flex flex-col items-end gap-1">
                            <div className="text-[10px] text-gray-400 bg-black/50 px-2 py-1 rounded backdrop-blur">CURRENT</div>
                            <div className="text-xl font-bold text-white drop-shadow-md">{currentCueObj?.name || "No Cue"}</div>
                            <div className="text-xs text-gray-300 bg-purple-900/50 px-2 py-0.5 rounded border border-purple-500/30">
                                {currentCueObj?.type === 'blackout' ? "BLACKOUT" : currentCueObj?.type === 'test' ? "TEST PATTERN" : "STANDARD"}
                            </div>
                        </div>
                    )}

                    <div className={`absolute inset-0 h-full z-0`}>
                        {viewMode === '2d' && (
                            <div className="absolute inset-0 z-10" onClick={() => setActiveWallId(null)}>
                            {(showTexture || viewMode === 'live' || menuTab === 'scenes') && (
                                <TransitioningProjectedContent prevCueState={prevCueState} currentCueState={currentCueState} mix={transitionMix} walls={walls} isLive={viewMode === 'live'} />
                            )}
                                {renderSVG(false)}
                                <div className="absolute top-4 left-4 pointer-events-none select-none drop-shadow-md z-50">
                                    {menuTab === 'scenes' ? (
                                        <div className="bg-black/50 px-3 py-2 rounded-lg backdrop-blur-sm">
                                            <div className="text-xs text-purple-300 font-bold">SCENE MODE</div>
                                            <div className="text-lg font-bold text-white">Act {currentSceneIndex + 1} - Cue {currentCueIndex + 1}</div>
                                        </div>
                                    ) : (<>
                                        <h1 className={`text-xl font-bold tracking-wider ${showTexture ? 'text-zinc-600' : 'text-white'}`}>MAPPING STUDIO</h1>
                                        <div className="flex gap-2 mt-1">
                                            <span className={`text-xs px-1.5 py-0.5 rounded font-mono border transition-colors ${moveMode ? 'bg-orange-600 border-orange-400 text-white' : 'bg-zinc-800 border-zinc-600 text-gray-200'}`}>W: Move All</span>
                                            <span className={`text-xs px-1.5 py-0.5 rounded font-mono border transition-colors ${showTexture ? 'bg-white text-black border-white font-bold' : 'bg-zinc-800 border-zinc-600 text-gray-200'}`}>T: Texture</span>
                                            <span className={`text-xs px-1.5 py-0.5 rounded font-mono border transition-colors ${showGuides ? 'bg-blue-900 border-blue-500 text-blue-200' : 'bg-zinc-800 border-zinc-600 text-gray-200'}`}>M: Guides</span>
                                            <span className="text-xs bg-zinc-800 px-1.5 py-0.5 rounded text-gray-200 font-mono border border-zinc-600">H: Menu</span>
                                        </div>
                                    </>)}
                                </div>
                            </div>
                        )}
                        {viewMode === 'live' && (
                            <div className="absolute inset-0 z-50 cursor-none bg-black">
                                <TransitioningProjectedContent prevCueState={prevCueState} currentCueState={currentCueState} mix={transitionMix} walls={walls} isLive={true} />
                                {renderSVG(true)}
                            </div>
                        )}
                    </div>

                    {menuTab === 'scenes' && viewMode !== 'live' && showNodeEditor && (
                        <div className="absolute bottom-0 left-0 right-0 h-[45%] z-30 border-t border-zinc-700/30 bg-zinc-900/50 backdrop-blur-md">
                            {activeSelection.type === 'cue' && (
                                <NodeEditor activeSelection={activeSelection} currentCue={currentCueObj} updateCueData={updateCueData} walls={walls} setWalls={setWalls} onOpenAssetBrowser={handleOpenAssetBrowser} />
                            )}
                            {activeSelection.type === 'transition' && (
                                <TransitionEditor cue={currentCueObj} updateCue={updateCueData} />
                            )}
                        </div>
                    )}

                    {menuOpen && viewMode !== 'live' && (
                        <div className="absolute right-4 top-4 bottom-4 w-64 bg-zinc-900/95 backdrop-blur border border-zinc-700 rounded-xl shadow-2xl z-50 flex flex-col overflow-hidden">
                            <div className="p-4 pb-0">
                                <button 
                                    onClick={() => {
                                        setViewMode('live');
                                        setMenuOpen(false);
                                    }}
                                    className="w-full bg-green-600 hover:bg-green-500 text-white font-bold py-3 rounded-lg shadow-lg flex items-center justify-center gap-2 transition-transform hover:scale-105"
                                >
                                    <Play size={20} fill="currentColor" /> GO LIVE
                                </button>
                            </div>
                            <div className="p-4 border-b border-zinc-700 flex justify-between items-center bg-zinc-900">
                                <span className="font-bold flex items-center gap-2"> <Settings size={18} /> Configuration </span>
                                <button onClick={() => setMenuOpen(false)} className="text-gray-400 hover:text-white">&times;</button>
                            </div>
                            <div className="flex border-b border-zinc-800 mt-4">
                                <button onClick={() => setMenuTab('config')} className={`flex-1 py-2 text-xs font-bold ${menuTab === 'config' ? 'text-blue-400 border-b-2 border-blue-400' : 'text-gray-500 hover:text-gray-300'}`}>Geometry</button>
                                <button onClick={() => setMenuTab('scenes')} className={`flex-1 py-2 text-xs font-bold ${menuTab === 'scenes' ? 'text-purple-400 border-b-2 border-purple-400' : 'text-gray-500 hover:text-gray-300'}`}>Scenes</button>
                            </div>

                            <div className="flex-1 overflow-y-auto p-4 space-y-6">
                                {menuTab === 'config' && (
                                    <>
                                        {viewMode === '2d' && (<div className="grid grid-cols-3 gap-2"><button onClick={() => setMoveMode(p => !p)} className={`p-2 rounded text-xs flex items-center justify-center gap-1 border transition-colors ${moveMode ? 'bg-orange-600 border-orange-400 text-white' : 'bg-zinc-800 border-zinc-700 text-gray-300'}`}> <Move size={14} /> Move </button><button onClick={() => setShowGuides(p => !p)} className={`p-2 rounded text-xs flex items-center justify-center gap-1 border transition-colors ${showGuides ? 'bg-blue-900/50 border-blue-500 text-blue-200' : 'bg-zinc-800 border-zinc-700 text-gray-300'}`}> <Grid3X3 size={14} /> Guide </button><button onClick={() => setShowTexture(p => !p)} className={`p-2 rounded text-xs flex items-center justify-center gap-1 border transition-colors ${showTexture ? 'bg-white text-black border-white font-bold' : 'bg-zinc-800 border-zinc-700 text-gray-300'}`}> <QrCode size={14} /> Tex </button></div>)}
                                        {activeWall && (<div className="space-y-3 bg-zinc-900 border border-zinc-700 p-3 rounded-lg"><div className="flex items-center gap-2 mb-2 pb-2 border-b border-zinc-800"><div className="w-3 h-3 rounded-full" style={{ backgroundColor: activeWall.color }}></div><input type="text" value={activeWall.name} onChange={(e) => setWalls(p => p.map(w => w.id === activeWall.id ? { ...w, name: e.target.value } : w))} className="bg-transparent border-none outline-none text-sm font-bold text-white w-full" /></div><div className="grid grid-cols-2 gap-2 mt-1"><div><label className="text-[10px] text-gray-500 flex items-center gap-1 mb-1"><Folder size={10}/> Group</label><select value={activeWall.folderId || ""} onChange={(e) => setWalls(p => p.map(w => w.id === activeWall.id ? { ...w, folderId: e.target.value ? parseInt(e.target.value) : null } : w))} className="w-full bg-zinc-800 border border-zinc-700 rounded px-2 py-1 text-xs text-white outline-none"><option value="">None</option>{folders.map(f => <option key={f.id} value={f.id}>{f.name}</option>)}</select></div><div><label className="text-[10px] text-gray-500 flex items-center gap-1 mb-1"><Palette size={10}/> Color</label><div className="flex items-center gap-2 bg-zinc-800 border border-zinc-700 rounded px-2 py-0.5"><input type="color" value={activeWall.color} onChange={(e) => setWalls(p => p.map(w => w.id === activeWall.id ? { ...w, color: e.target.value } : w))} className="w-4 h-4 p-0 border-none bg-transparent cursor-pointer" /><span className="text-xs text-gray-400 font-mono">{activeWall.color}</span></div></div></div></div>)}
                                        <div className="space-y-2"><div className="flex justify-between items-center"><h3 className="text-xs font-bold text-gray-500">OBJECTS</h3><div className="flex gap-1"><button onClick={addFolder} className="text-xs bg-zinc-800 hover:bg-zinc-700 px-2 py-1 rounded flex items-center gap-1" title="New Group"> <FolderPlus size={12} /> </button><button onClick={() => { const newId = Math.max(0, ...walls.map(w => w.id)) + 1; setWalls(p => [...p, { id: newId, name: `Obj ${newId}`, color: `hsl(${Math.random()*360},70%,60%)`, folderId: null, points: [{x:300,y:300},{x:400,y:300},{x:400,y:400},{x:300,y:400}] }]); }} className="text-xs bg-zinc-800 hover:bg-zinc-700 px-2 py-1 rounded flex items-center gap-1" title="New Object"> <Plus size={12} /> </button></div></div>{folders.map(folder => (<FolderItem key={folder.id} folder={folder} walls={walls} activeWallId={activeWallId} setActiveWallId={setActiveWallId} setWalls={setWalls} setFolders={setFolders} moveWall={moveWall} deleteWall={deleteWall} />))}{walls.filter(w => w.folderId === null).map(wall => (<WallItem key={wall.id} wall={wall} activeWallId={activeWallId} setActiveWallId={setActiveWallId} moveWall={moveWall} deleteWall={deleteWall} />))}</div>
                                        
                                        <WallStackVisualizer walls={walls} activeWallId={activeWallId} />

                                        {/* STORAGE SECTION */}
                                        <div className="mt-4 pt-4 border-t border-zinc-700">
                                            <div className="flex justify-between items-center mb-2">
                                                <h3 className="text-xs font-bold text-gray-500 flex items-center gap-1"><Database size={12}/> STORAGE</h3>
                                                {storageUsage && <span className="text-[10px] text-zinc-500">{storageUsage.usage}MB / {storageUsage.quota}MB</span>}
                                            </div>
                                            <button onClick={resetData} className="w-full text-xs text-red-400 border border-red-900/50 hover:bg-red-900/20 py-1 rounded flex items-center justify-center gap-2 transition-colors">
                                                <HardDrive size={12}/> Reset All Data
                                            </button>
                                        </div>
                                    </>
                                )}

                                {/* --- SCENES TAB --- */}
                                {menuTab === 'scenes' && (
                                    <div className="space-y-4">
                                        <div className="flex gap-2 border-b border-zinc-800 pb-2 mb-2">
                                            <button onClick={() => setShowNodeEditor(p => !p)} className={`w-full p-2 rounded text-xs flex items-center justify-center gap-1 border transition-colors ${showNodeEditor ? 'bg-purple-900/50 border-purple-500 text-purple-200' : 'bg-zinc-800 border-zinc-700 text-gray-300'}`} title="Toggle Node Editor">
                                                {showNodeEditor ? <Eye size={14}/> : <EyeOff size={14}/>} {showNodeEditor ? 'Hide Graph' : 'Show Graph'}
                                            </button>
                                        </div>
                                        <div className="space-y-1">
                                            <div className="flex justify-between items-center mb-2">
                                                <h3 className="text-xs font-bold text-gray-400 uppercase">Cue List</h3>
                                                <button onClick={addScene} className="text-xs bg-purple-600 hover:bg-purple-500 px-2 py-1 rounded flex items-center gap-1 text-white ml-2"><Plus size={12}/> Act</button>
                                            </div>
                                            {scenes.map((scene, sIdx) => (
                                                <div key={scene.id} className="mb-3">
                                                    <div className="px-2 py-1 text-xs font-bold text-gray-500 uppercase border-b border-zinc-800 mb-1 flex justify-between items-center">
                                                        <span className="flex items-center gap-2"><Film size={10}/> {scene.name}</span>
                                                        <div className="flex items-center gap-1">
                                                            <button onClick={() => moveScene(sIdx, -1)} className="text-gray-500 hover:text-white p-0.5"><ChevronUp size={12}/></button>
                                                            <button onClick={() => moveScene(sIdx, 1)} className="text-gray-500 hover:text-white p-0.5"><ChevronDown size={12}/></button>
                                                            <button onClick={() => deleteScene(scene.id)} className="text-gray-500 hover:text-red-400 p-0.5" title="Delete Act"><Trash2 size={12}/></button>
                                                            <button onClick={() => addCue(scene.id)} className="text-[9px] bg-zinc-800 hover:bg-zinc-700 px-1.5 py-0.5 rounded text-gray-300 ml-1">+ Cue</button>
                                                        </div>
                                                    </div>
                                                    <div className="space-y-0 pl-1">
                                                        {scene.cues.map((cue, cIdx) => {
                                                            const isActive = activeSelection.type === 'cue' && activeSelection.sceneId === scene.id && activeSelection.cueId === cue.id;
                                                            const nextCue = scene.cues[cIdx + 1] || (scenes[sIdx+1]?.cues[0]);
                                                            return (
                                                                <div key={cue.id}>
                                                                    <div onClick={() => setActiveSelection({ type: 'cue', sceneId: scene.id, cueId: cue.id })} className={`flex items-center gap-2 p-2 rounded text-xs cursor-pointer transition-all group ${isActive ? 'bg-purple-900/50 border-l-2 border-purple-400 text-white' : 'hover:bg-zinc-800 text-gray-400 border-l-2 border-transparent'}`}>
                                                                        {isActive ? <Play size={10} fill="currentColor"/> : <span className="w-2.5"/>}
                                                                        <span className="truncate flex-1">{cue.name}</span>
                                                                        <div className="flex items-center gap-1 opacity-0 group-hover:opacity-100 transition-opacity">
                                                                            <button onClick={(e) => { e.stopPropagation(); moveCue(scene.id, cIdx, -1); }} className="text-gray-500 hover:text-white p-0.5"><ChevronUp size={10}/></button>
                                                                            <button onClick={(e) => { e.stopPropagation(); moveCue(scene.id, cIdx, 1); }} className="text-gray-500 hover:text-white p-0.5"><ChevronDown size={10}/></button>
                                                                            <button onClick={(e) => { e.stopPropagation(); deleteCue(scene.id, cue.id); }} className="text-gray-500 hover:text-red-400 p-0.5" title="Delete Cue"><Trash2 size={10}/></button>
                                                                        </div>
                                                                    </div>
                                                                    {nextCue && (
                                                                        <div className={`h-2 my-0.5 rounded-full mx-2 cursor-pointer hover:bg-purple-500/50 transition-colors group relative flex justify-center items-center ${activeSelection.type === 'transition' && activeSelection.nextCueId === nextCue.id ? 'bg-purple-500' : 'bg-zinc-800'}`} onClick={() => setActiveSelection({ type: 'transition', sceneId: scene.id, prevCueId: cue.id, nextCueId: nextCue.id })}>
                                                                            <div className="w-3 h-3 rounded-full bg-zinc-600 border border-zinc-900 group-hover:bg-white group-hover:scale-125 transition-transform flex items-center justify-center"><Link size={8} className="text-zinc-900"/></div>
                                                                        </div>
                                                                    )}
                                                                </div>
                                                            )
                                                        })}
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    </div>
                                )}
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>